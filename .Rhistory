rm(list=ls())
classic_layers_turnover_with_distances <- read.csv("classic_layers_turnover_with_distances.csv")
classic_layers_turnover_with_distances <- classic_layers_turnover_with_distances%>% mutate(distance_in_km=distance_in_meters/1000)
classic_layers_turnover_with_distances %>%
ggplot(aes(x=distance_in_km, y=turnover))+ geom_point(color = "indianred2")+ theme_classic()+
stat_smooth(method= "lm", se=F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
classic_layers_turnover_with_distances_shuf_pols <- read.csv("classic_layers_turnover_with_distances_shuf_pols.csv")
classic_layers_turnover_with_distances_shuf_plants <- read.csv("classic_layers_turnover_with_distances_shuf_plants.csv")
classic_layers_turnover_with_distances_shuf_both <- read.csv("classic_layers_turnover_with_distances_shuf_both.csv")
#create an average for shuf with sd
#pols
ave_turnover_for_shuf_pols <- classic_layers_turnover_with_distances_shuf_pols %>%
group_by(layer_from, layer_to, distance_in_meters) %>%
summarise(ave=mean(turnover), sd=sd(turnover)) %>% mutate(type="null_pollinators") #create mean and sd for each point
#plants
ave_turnover_for_shuf_plants <- classic_layers_turnover_with_distances_shuf_plants %>%
group_by(layer_from, layer_to, distance_in_meters) %>%
summarise(ave=mean(turnover), sd=sd(turnover)) %>% mutate(type="null_plants") #create mean and sd for each point
#both
ave_turnover_for_shuf_both <- classic_layers_turnover_with_distances_shuf_both %>%
group_by(layer_from, layer_to, distance_in_meters) %>%
summarise(ave=mean(turnover), sd=sd(turnover)) %>% mutate(type="null_both") #create mean and sd for each point
#empirical
classic_layers_turnover_with_distances <- read.csv("classic_layers_turnover_with_distances.csv")
empirical_turnover_for_shuf <- classic_layers_turnover_with_distances %>%
group_by(layer_from, layer_to, distance_in_meters) %>%
summarise(ave=mean(turnover), sd=sd(turnover)) %>% mutate(type="empirical")
#---- graphs for distance decay in species-----------------------------------------------------
turnover_shuf_and_empirical <- rbind(empirical_turnover_for_shuf, ave_turnover_for_shuf_pols, ave_turnover_for_shuf_plants, ave_turnover_for_shuf_both)
turnover_shuf_and_empirical <- turnover_shuf_and_empirical %>% mutate(distance_in_km = distance_in_meters/1000)
turnover_shuf_and_empirical %>%
ggplot(aes(x= distance_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13),legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))
layers_turnover_with_distnace_empirical <- read.csv("layers_turnover_with_distnace_empirical.csv")
#---- graphs for distance decay in modules empirical---
layers_turnover_with_distnace_empirical %>%
ggplot(aes(x=distance_in_km, y=turnover))+
geom_point(color = "indianred2")+ scale_x_continuous()+theme_classic()+
stat_smooth(method= "lm", se = F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
jaccard_similarity_layer_empirical_and_null_no_self_loop_km <- read.csv("jaccard_similarity_layer_empirical_and_null_no_self_loop_km.csv")
#---- graphs for distance decay in modules empirical and null model 1---
jaccard_similarity_layer_empirical_and_null_no_self_loop_km %>%
ggplot(aes(x= ave_dist, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.60, 0.56, 0.52, 0.48))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
correlation_empirical_pols <- read.csv("correlation_empirical_pols.csv")
rqsuares_M1_all <- read.csv("rqsuares_M1_all.csv")
group_color <- c(shuf_pollinators = "#BE75FA",
shuf_plants = "#15B7BC",
shuf_both = "#72A323")
rqsuares_M1_all %>%
ggplot(aes(x = rsquared, fill = type))+
geom_density(alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_pols$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())+
scale_fill_manual(values = group_color)
#Shuffled
all_edge_list_sites_combine_no_module_shuf_classic <- read.csv("all_edge_list_sites_combine_no_module_shuf_classic.csv")
ave_module_sites_turnover_shuf_classic <- all_edge_list_sites_combine_no_module_shuf_classic %>%
group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(ave_distance)) %>% mutate(type="null_model_within") #create mean and sd for each point
#add the empirical empirical
sites_turnover_with_distnace_empirical <- read.csv("sites_turnover_with_distnace_empirical.csv")
empirical_turnover_for_module_site_shuf <- sites_turnover_with_distnace_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(distance_in_km)) %>% mutate(ave_dist= ave_dist*1000,
type="empirical") #make sure sd is 0 cause its the empirical and not null
empirical_turnover_for_module_site_shuf_no_self_loop_classic <- empirical_turnover_for_module_site_shuf %>%
subset(layer_from != layer_to) #distance decay graph for empirical
empirical_turnover_for_module_site_shuf_no_self_loop_km_classic <- empirical_turnover_for_module_site_shuf_no_self_loop_classic %>%
mutate(ave_dist_in_m = ave_dist*1000) #From km to m
##---- combine empirical and shuffle
jaccard_similarity_empirical_and_null_model <- rbind(empirical_turnover_for_module_site_shuf, ave_module_sites_turnover_shuf_classic)
jaccard_similarity_empirical_and_null_no_self_loop_classic <- jaccard_similarity_empirical_and_null_model %>% subset(layer_from != layer_to)
jaccard_similarity_empirical_and_null_no_self_loop_km_classic <- jaccard_similarity_empirical_and_null_no_self_loop_classic %>%
mutate(ave_dist_in_km = ave_dist/1000) #all data set from m to km
just_empirical_within <- jaccard_similarity_empirical_and_null_no_self_loop_km_classic %>% filter(type == "empirical")
jaccard_similarity_empirical_and_null_no_self_loop_km_classic %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.57, 0.54))+ scale_color_manual(values = c("#F47069", "#c4067c"))
correlation_empirical_classic <- read.csv("correlation_empirical_pols.csv")
iteration_correlation_classic <- read.csv("iteration_correlation_classic.csv")
#Distribution of rsquared and add empirical
iteration_correlation_classic %>% ggplot(aes(x = rsquared))+
geom_density(fill = "#c4067c", color = "#c4067c", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_classic$rsquared, linetype = "dashed", color = "#F47069")
jaccard_similarity_empirical_and_null_interactions_no_self_loop_km <- read.csv("jaccard_similarity_empirical_and_null_interactions_no_self_loop_km.csv")
jaccard_similarity_empirical_and_null_interactions_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.63, 0.60, 0.57, 0.54))+
scale_color_manual(values = c("#F47069", "#0033cc"))
correlation_empirical_interactions <- read.csv("correlation_empirical_pols.csv")
iteration_correlation_interactions  <- read.csv("iteration_correlation_interactions.csv")
#Distribution of rsquared and add empirical
iteration_correlation_interactions %>% ggplot(aes(x = rsquared))+
geom_density(fill = "#0033cc", color = "#0033cc", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
iteration_correlation_pols <- read.csv("iteration_correlation_pols.csv")
iteration_correlation_interactions<- read.csv("iteration_correlation_interactions.csv")
correlation_empirical_interactions <- read.csv("correlation_empirical_pols.csv")
interactions_for_beta_diversity <- iteration_correlation_interactions
interactions_for_beta_diversity$type <- "shuffling_interactions"
species_for_beta_diversity <- iteration_correlation_pols
species_for_beta_diversity$type <- "shuffling_species"
correlation_beta_diversity <- rbind(interactions_for_beta_diversity, species_for_beta_diversity)
correlation_beta_diversity %>% ggplot(aes(x = rsquared, color = type, fill = type))+ #overlay shuffling of interactions and species
geom_density(alpha = 0.4)+ scale_color_manual(values = c("#0033cc", "#BE75FA"))+
scale_fill_manual(values = c("#0033cc", "#BE75FA"))+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
jaccard_similarity_empirical_and_fixed_no_self_loop_km<- read.csv("jaccard_similarity_empirical_and_fixed_no_self_loop_km.csv")
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())+ stat_cor(aes(label = ..p.label..), label.x = 400)+stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))
classic_layers_turnover_with_distances_island <- read.csv("classic_layers_turnover_with_distances_islands_as_layers.csv")
classic_layers_turnover_with_distances <- classic_layers_turnover_with_distances_island %>%
mutate(distance_in_km=mean_distance/1000) #turn to km
classic_layers_turnover_with_distances %>%
ggplot(aes(x=distance_in_km, y=turnover))+ geom_point(color = "indianred2")+ theme_classic()+
stat_smooth(method= "lm", se=F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
turnover_shuf_and_empirical <- read.csv("turnover_shuf_and_empirical_islands_as_layers.csv")
turnover_shuf_and_empirical %>% ggplot(aes(x= distance_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
labs(x="Distance in Km", y="Jaccard Similarity")+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))
islands_turnover_with_distnace_empirical <- read.csv("islands_turnover_with_distnace_empirical.csv")
islands_turnover_with_distnace_empirical %>%
ggplot(aes(x=distance_in_km, y=turnover))+
geom_point(color = "indianred2")+
scale_x_continuous()+ stat_smooth(method= "lm", se=F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+ theme_bw()+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
jaccard_similarity_layer_empirical_and_null_km <- read.csv("jaccard_similarity_layer_empirical_and_null_km_islands.csv")
jaccard_similarity_layer_empirical_and_null_km %>%
ggplot(aes(x= mean_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.60, 0.56, 0.52, 0.48))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) # stat_cor(aes(label = ..p.label..), label.x = 400)+
correlation_empirical_pols <- read.csv("correlation_empirical_pols_islands.csv")
rqsuares_M1_all <- read.csv("rqsuares_M1_all_islands.csv")
group_color <- c(shuf_pollinators = "#BE75FA",
shuf_plants = "#15B7BC",
shuf_both = "#72A323")
rqsuares_M1_all %>%
ggplot(aes(x = rsquared, fill = type))+
geom_density(alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_pols$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())+
scale_fill_manual(values = group_color)
jaccard_similarity_layer_empirical_and_null_km  <- read.csv("jaccard_similarity_layer_empirical_and_null_km_islands.csv")
jaccard_similarity_layer_empirical_and_null_km %>%
ggplot(aes(x= mean_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.60, 0.56, 0.52, 0.48))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)
#distribution of rsquared and add empirical
correlation_empirical_interactions <- read.csv("correlation_empirical_interactions_islands.csv")
iteration_correlation_interactions <- read.csv("iteration_correlation_interactions_islands.csv")
iteration_correlation_interactions %>% ggplot(aes(x = rsquared))+
geom_density(fill = "#0033cc", color = "#0033cc", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
##compare both parts of beta diversity (shuffling pollinator species )
iteration_correlation_pols <- read.csv("iteration_correlation_pols_islands.csv")
iteration_correlation_interactions <- read.csv("iteration_correlation_interactions_islands.csv")
correlation_empirical_interactions <- read.csv("correlation_empirical_interactions_islands.csv")
interactions_for_beta_diversity <- iteration_correlation_interactions
interactions_for_beta_diversity$type <- "shuffling_interactions"
species_for_beta_diversity <- iteration_correlation_pols
species_for_beta_diversity$type <- "shuffling_species"
correlation_beta_diversity <- rbind(interactions_for_beta_diversity, species_for_beta_diversity)
correlation_beta_diversity %>% ggplot(aes(x = rsquared, color = type, fill = type))+ #overlay shuffling of interactions and species
geom_density(alpha = 0.4)+ scale_color_manual(values = c("#0033cc", "#BE75FA"))+
scale_fill_manual(values = c("#0033cc", "#BE75FA"))+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
jaccard_similarity_empirical_and_fixed_no_self_loop_km<- read.csv("jaccard_similarity_empirical_and_fixed_no_self_loop_km_islands.csv")
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))
##---load_libraries-------------------------------------------------------------------------------------------------
options(rgl.useNULL = TRUE)
library(infomapecology)
library(igraph)
library(bipartite)
library(tidyverse)
library(magrittr)
library(betalink)
library(readxl)
library(ggalluvial)
library(scatterpie)
library(reshape2)
library(ggforce)
library(ggmap)
library(ggraph)
library(ggpubr)
setwd("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands")
source("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands/R/functions.R")
##---- fixed for empirical data ---------------------------------------------------------------------------
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
#Set fixed interlayer value to median of interlayer distribution
median(inter_extended$weight)
interlayer_edges_change <- select(inter_extended, -weight) #create data frame where weight doesn't exist
interlayer_edges_change$weight <- 0.9011 #set fixed interlayer value to median of interlayer distribution
#calculate modularity
dryad_multilayer_fixed <- create_multilayer_object(intra = intra_nonextended,
inter = interlayer_edges_change, #create multilayer with new fixed inter value
nodes = physical_nodes,
layers = layer_metadata,
intra_output_extended = T)
modules_edge_change_fixed <- modified_multi(dryad_multilayer_fixed,
infomap_executable = "Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294,
temporal_network = F)
# fixed
modules_fixed <- modules_edge_change_fixed$modules
## empirical
modules <- read.csv('./csvs/Islands/modules_in_network_islands_as_layers.csv')
modules_dryad_multilayer_fixed_analysis <- modules #create version just for the analysis
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
#pivot modules function for islands as layers
pivot_by_module_islands <- function(data){ #creates a data frame with module on the side and layer_id on the top
s1 = melt(data, id = c("layer_id", "module"))
s2 = dcast(s1, layer_id ~ module, length)
s3 = t(s2)
s3 <- s3[-1,]
colnames(s3) <- c(1,2,3,4,5,6,7)
return(s3)
}
module_pivoted_fixed <- pivot_by_module_islands(modules_fixed) #pivot for fixed
module_pivoted_empirical_fixed_analysis <- pivot_by_module_islands(modules_dryad_multilayer_fixed_analysis) #pivot for empirical
#Define function edge_list_per module for islands
edge_list_per_module <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:6)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):7)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
#for fixed
modules_edge_list_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_fixed))){ #run the function for each row in the data frame
modules_edge_list_fixed_analysis <- edge_list_per_module_islands(module_pivoted_fixed[k,], modules_edge_list_fixed_analysis)
current_module_fixed <- rownames(module_pivoted_fixed)[k]
if (is.null(modules_edge_list_fixed_analysis)) next
modules_edge_list_fixed_analysis <- modules_edge_list_fixed_analysis %>% mutate(module = replace_na(module, current_module_fixed)) #add module number
}
# for empirical
modules_edge_list_empirical_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_fixed))){ #run the function for each row in the data frame
modules_edge_list_fixed_analysis <- edge_list_per_module(module_pivoted_fixed[k,], modules_edge_list_fixed_analysis)
current_module_fixed <- rownames(module_pivoted_fixed)[k]
if (is.null(modules_edge_list_fixed_analysis)) next
modules_edge_list_fixed_analysis <- modules_edge_list_fixed_analysis %>% mutate(module = replace_na(module, current_module_fixed)) #add module number
}
#Define function edge_list_per module for islands
edge_list_per_module_islands <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:6)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):7)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
#for fixed
modules_edge_list_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_fixed))){ #run the function for each row in the data frame
modules_edge_list_fixed_analysis <- edge_list_per_module_islands(module_pivoted_fixed[k,], modules_edge_list_fixed_analysis)
current_module_fixed <- rownames(module_pivoted_fixed)[k]
if (is.null(modules_edge_list_fixed_analysis)) next
modules_edge_list_fixed_analysis <- modules_edge_list_fixed_analysis %>% mutate(module = replace_na(module, current_module_fixed)) #add module number
}
# for empirical
modules_edge_list_empirical_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_empirical_fixed_analysis))){ #run the function for each row in the data frame
modules_edge_list_empirical_fixed_analysis <- edge_list_per_module_islands(module_pivoted_empirical_fixed_analysis[k,], modules_edge_list_empirical_fixed_analysis)
current_module_empirical <- rownames(module_pivoted_empirical_fixed_analysis)[k]
if (is.null(modules_edge_list_empirical_fixed_analysis)) next
modules_edge_list_empirical_fixed_analysis <- modules_edge_list_empirical_fixed_analysis %>% mutate(module = replace_na(module, current_module_empirical)) #add module number
}
#edge list by island for fixed------------------------------------------------------------------------------------------------------------
distances_with_ids <- read.csv("./csvs/Islands/distances_with_ids_islands_as_layers.csv")
edge_list_with_distances_fixed <- right_join(modules_edge_list_fixed_analysis, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
edge_list_with_distances_fixed <- na.omit(edge_list_with_distances_fixed) #remove NA and delete layer name
#version with # of modules in layers
edge_list_by_layer_modules_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(mean_distance))
edge_list_by_layer_modules_fixed$count <- c(1)
edge_list_by_layer_modules_fixed <- edge_list_by_layer_modules_fixed %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, layer_to, module, number_of_modules)
#version with correct average between layers
edge_list_by_layer_ave_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(mean_distance)) %>% unique()
#combine
edge_list_layer_combine_fixed <- edge_list_by_layer_ave_fixed %>%
merge(edge_list_by_layer_modules_fixed, by= c("layer_from", "layer_to")) #merge both versions
edge_list_layer_combine_no_module_fixed_analysis <- edge_list_layer_combine_fixed %>% select(-module) %>% unique() #have version where modules aren't present
#module data
size <- count(modules_edge_change_fixed$modules, module)  #create a data frame of all modules and how many nodes are in each (size of module)
module_data <- merge(modules_edge_change_fixed$modules , size, by=c("module","module")) #merge size of module with all the other info about the modules
colnames(module_data)[7] <- "size_of_module" #rename column
lon_lat_data <- read.csv("./csvs/Islands/lon_lat_data_islands_as_layers.csv")
module_data_with_loc <- merge(module_data, lon_lat_data, by= c("layer_id","layer_id")) #merge modules with module size with the coordinates
#how many layers are within a module
modules_with_lat_lon <- module_data_with_loc %>% select(layer_id, module, lat, Lon, size_of_module) %>% unique() #take only certain columns
modules_with_lat_lon$count <- c(1)
# total number of modules in each island
module_layer_turnover_fixed_analysis <- NULL
for (i in 1:7){
for (j in 1:7){
modules_in_layer_from_fixed_analysis <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_fixed_analysis <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_fixed_analysis, modules_in_layer_to_fixed_analysis) #how many sub modules are common in both layers
uni_both <- union(modules_in_layer_from_fixed_analysis, modules_in_layer_to_fixed_analysis) #how many sub modules are found in both layers in total
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_fixed_analysis <- rbind(module_layer_turnover_fixed_analysis, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_layer_turnover_fixed_analysis <- drop_na(module_layer_turnover_fixed_analysis)
layer_turnover_with_distnace_fixed <- edge_list_by_layer_ave_fixed %>%
merge(module_layer_turnover_fixed_analysis, by= c("layer_from", "layer_to")) #merge both versions
#---- edge list by island empirical-------------------------------------------------------------------------------------------------------------
edge_list_with_distances_empirical <- right_join(modules_edge_list_empirical_fixed_analysis,
distances_with_ids, by= c("layer_from", "layer_to"))
edge_list_with_distances_empirical <- na.omit(edge_list_with_distances_empirical) #remove NA
#version with # of modules in layers
edge_list_by_layer_modules_empirical <- edge_list_with_distances_empirical %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(mean_distance))
edge_list_by_layer_modules_empirical$count <- c(1)
edge_list_by_layer_modules_empirical <- edge_list_by_layer_modules_empirical %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, layer_to, module, number_of_modules)
#total number of modules in each layer
modules_with_lat_lon_empirical <- read.csv("csvs/Islands/modules_with_lat_lon_islands_as_layers.csv")
module_layer_turnover_empirical <- NULL
for (i in 1:7){
for (j in 1:7){
modules_in_layer_from_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis) #how many sub modules are found in both layers
uni_both <- union(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_empirical <- rbind(module_layer_turnover_empirical, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_layer_turnover_empirical <- drop_na(module_layer_turnover_empirical)
edge_list_by_layer_ave_empirical <- edge_list_with_distances_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(mean_distance)) %>% unique()
layer_turnover_with_distnace_empirical <- edge_list_by_layer_ave_empirical %>%
merge(module_layer_turnover_empirical, by= c("layer_from", "layer_to")) #merge both versions
#----prepare data for graph--------------------------------------------------------------------------------------------------------
ave_module_layer_turnover_shuf_fixed <- layer_turnover_with_distnace_fixed %>%
group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(ave_distance)) %>% mutate(type="null_fixed") #create mean and sd for each point
## empirical
empirical_turnover_for_module_layer_analysis <- layer_turnover_with_distnace_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(ave_distance)) %>% mutate(type="empirical") #make sure sd is 0 cause its the empirical and not null
#combine all layers
jaccard_similarity_empirical_and_fixed <- rbind(empirical_turnover_for_module_layer_analysis,
ave_module_layer_turnover_shuf_fixed)
jaccard_similarity_empirical_and_fixed_no_self_loop <- jaccard_similarity_empirical_and_fixed %>% subset(layer_from != layer_to)
jaccard_similarity_empirical_and_fixed_no_self_loop_km <- jaccard_similarity_empirical_and_fixed_no_self_loop %>%
mutate(ave_dist_in_km = ave_dist/1000)
#just empirical
jaccard_similarity_empirica_no_self_loop_km <- jaccard_similarity_empirical_and_fixed_no_self_loop_km %>%
filter(type == "empirical")
jaccard_similarity_empirica_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave))+
geom_point()+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.text = element_text(size = 13), legend.title = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")

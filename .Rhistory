output <- rbind(output, tibble(modules_dryad_multilayer_shuf_1000$modules, trial_num)) #
}
return(output)
}
#calculate modularity according to each interedges weight
dryad_multilayer_complete_fixed_output <- modularity_for_fixed(dryad_edgelist_complete_fixed,
dryad_multilayer_complete_fixed)
#Plot number of modules according to interedges values
N_modules_inter <- dryad_multilayer_complete_fixed_output %>%
group_by(trial_num) %>% summarise(Num_modules = max(module)) %>% rename(inter_edges = 1)
#Plot number of modules according to interedges values
N_modules_inter <- dryad_multilayer_complete_fixed_output %>%
group_by(trial_num) %>% summarise(Num_modules = max(module)) %>% rename(inter_edges = 1)
N_modules_inter_empirical<- ggplot(N_modules_inter, aes(x = inter_edges, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+ scale_y_continuous(breaks=seq(0,35,5))+
labs(x='Interedges', y="Number of modules")+ theme(axis.text.x = element_text(size=15),
axis.text.y=element_text(size=15), axis.title = element_text(size=17))
N_modules_inter_empirical
N_modules_inter_empirical<- ggplot(N_modules_inter, aes(x = inter_edges, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+ scale_y_continuous(breaks=seq(0,90,10))+
labs(x='Interedges', y="Number of modules")+ theme(axis.text.x = element_text(size=15),
axis.text.y=element_text(size=15), axis.title = element_text(size=17))
N_modules_inter_empirical
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
dryad_multilayer_relax <- create_multilayer_object(intra = intra_nonextended,
inter = inter_extended,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = F)
# Ignore interlayer edges
dryad_multilayer_relax$inter <- NULL
#Run Infomap and return the network's modular structure at increasing relax-rates.
relaxrate_modules <- NULL
for (r in seq(0.1,1, by = 0.1)){
print(r)
modules_relax_rate <- run_infomap_multilayer(dryad_multilayer_relax, relax = T, silent = T, trials = 100, seed = 497294, multilayer_relax_rate = r, multilayer_relax_limit_up = 1, multilayer_relax_limit_down = 0, temporal_network = F)
modules_relax_rate$modules$relax_rate <- r
relaxrate_modules <- rbind(relaxrate_modules, modules_relax_rate$modules)
}
#Plot number of modules according to relax rate
N_modules_relax <- relaxrate_modules %>%
group_by(relax_rate) %>% summarise(Num_modules = max(module))
N_modules_relax_empirical<- ggplot(N_modules_relax, aes(x = relax_rate, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+scale_y_continuous(limits= c(0,90),breaks=seq(0,90,10))+
labs(x='Relax rate', y="Number of modules")+ theme(axis.text.x = element_text(size=15),
axis.text.y=element_text(size=15), axis.title = element_text(size=17))
N_modules_relax_Klil
N_modules_relax_empirical
#Plot together  (ver si hacer grafico de distribucion)
plot_grid(N_modules_inter_empirical,
N_modules_relax_empirical,
nrow = 2)
library(infomapecology)
library(infomapecology)
library(igraph)
library(bipartite)
library(tidyverse)
library(magrittr)
library(betalink)
library(readxl)
library(ggalluvial)
library(scatterpie)
library(reshape2)
library(ggforce)
library(ggmap)
library(ggraph)
library(ggpubr)
setwd("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands")
source("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands/R/functions.R")
##---- fixed for empirical data ---------------------------------------------------------------------------
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
## - Set fixed interlayer value to median of interlayer distribution
interlayer_edges_change <- select(inter_extended, -weight) #create data frame where weight doesn't exist
##Create scenarios where we change the interedges weight from 0 to 1
k<-seq(0.1,1,by=0.1)
Sen_list_classic = NULL
for(t in k){
output<- interlayer_edges_change %>%
mutate(weight = t)#set fixed interlayer value to t
Sen_list_classic<- rbind(Sen_list_classic,output)
}
# ----multilayer_class-----------------------------------------------------------------------------------------------
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
# Input: An extended edge list.
dryad_edgelist_complete_fixed <- Sen_list_classic
dryad_multilayer_complete_fixed <- NULL
#Function to calculate modularity according to each interedge weight
modularity_for_fixed <- function(edge_list, output){
for(trial_num in k){
current_trial_edgelist <- edge_list%>% filter(weight == trial_num) #take 1 trial at a time to create multilayer
dryad_multilayer_shuf_trial <- create_multilayer_object(intra = intra_nonextended,
inter = current_trial_edgelist,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = T)
#create modules for empirical network
modules_dryad_multilayer_shuf_1000 <- run_infomap_multilayer(dryad_multilayer_shuf_trial,
infomap_executable = "Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294, #always the same seed
temporal_network = F)
output <- rbind(output, tibble(modules_dryad_multilayer_shuf_1000$modules, trial_num)) #
}
return(output)
}
##- High relax rate
r= 0.9
rel<-create_multilayer_object(intra = intra_nonextended,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = F)
rel_mod <- run_infomap_multilayer(rel, relax = T, silent = T, trials = 100, seed = 497294, multilayer_relax_rate = r, multilayer_relax_limit_up = 1, multilayer_relax_limit_down = 0, temporal_network = F)
# Data: Plant-pollinator multilayer network
Contained four components:
1. Seven layers (six islands and the mainland).
knitr::opts_chunk$set(echo = FALSE, results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='40%')
library(infomapecology)
library(bipartite)
library(tidyverse)
library(magrittr)
library(betalink)
library(readxl)
library(ggalluvial)
library(scatterpie)
library(reshape2)
library(ggforce)
library(ggmap)
library(ggraph)
library(ggpubr)
rm(list=ls())
intra_inter_data_for_distibution <- read.csv("intra_inter_data_for_distibution_islands_as_layers.csv")
intra_inter_data_for_distibution %>%
ggplot(aes(x=values, fill=group))+ geom_histogram(position= "identity", alpha= 0.6, color= "black")+ theme_bw()+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
dryad_multilayer_relax <- create_multilayer_object(intra = intra_nonextended,
inter = inter_extended,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = F)
# Ignore interlayer edges
dryad_multilayer_relax$inter <- NULL
#Run Infomap and return the network's modular structure at increasing relax-rates.
relaxrate_modules <- NULL
##---- fixed for empirical data ---------------------------------------------------------------------------
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
## - Set fixed interlayer value to median of interlayer distribution
interlayer_edges_change <- select(inter_extended, -weight) #create data frame where weight doesn't exist
##Create scenarios where we change the interedges weight from 0 to 1
k<-seq(0.1,1,by=0.1)
Sen_list_classic = NULL
for(t in k){
output<- interlayer_edges_change %>%
mutate(weight = t)#set fixed interlayer value to t
Sen_list_classic<- rbind(Sen_list_classic,output)
}
# ----multilayer_class-----------------------------------------------------------------------------------------------
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
# Input: An extended edge list.
dryad_edgelist_complete_fixed <- Sen_list_classic
dryad_multilayer_complete_fixed <- NULL
#Function to calculate modularity according to each interedge weight
modularity_for_fixed <- function(edge_list, output){
for(trial_num in k){
current_trial_edgelist <- edge_list%>% filter(weight == trial_num) #take 1 trial at a time to create multilayer
dryad_multilayer_shuf_trial <- create_multilayer_object(intra = intra_nonextended,
inter = current_trial_edgelist,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = T)
#create modules for empirical network
modules_dryad_multilayer_shuf_1000 <- run_infomap_multilayer(dryad_multilayer_shuf_trial,
infomap_executable = "Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294, #always the same seed
temporal_network = F)
output <- rbind(output, tibble(modules_dryad_multilayer_shuf_1000$modules, trial_num)) #
}
return(output)
}
#calculate modularity according to each interedges weight
dryad_multilayer_complete_fixed_output <- modularity_for_fixed(dryad_edgelist_complete_fixed,
dryad_multilayer_complete_fixed)
dryad_multilayer_complete_fixed_output <- dryad_multilayer_complete_fixed_output %>% drop_na()
write.csv(dryad_multilayer_complete_fixed_output, "./R/Extra_analysis_results/inter_empirical.csv", row.names = FALSE)
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
inter_extended <- read.csv("./csvs/Islands/dryad_only_interlayer_edges_islands_as_layers.csv")
intra_nonextended <- read.csv("./csvs/Islands/dryad_only_intralayer_edges_islands_as_layers.csv")
inter_extended <- inter_extended [,-1]
intra_nonextended <- intra_nonextended [,-1]
dryad_multilayer_relax <- create_multilayer_object(intra = intra_nonextended,
inter = inter_extended,
nodes = physical_nodes, #nodes are always the same. we're not deleting nodes.
layers = layer_metadata, #layers are always the same. we're not deleting layers.
intra_output_extended = F)
# Ignore interlayer edges
dryad_multilayer_relax$inter <- NULL
#Run Infomap and return the network's modular structure at increasing relax-rates.
relaxrate_modules <- NULL
for (r in seq(0.1,1, by = 0.1)){
print(r)
modules_relax_rate <- run_infomap_multilayer(dryad_multilayer_relax, relax = T, silent = T, trials = 100, seed = 497294, multilayer_relax_rate = r, multilayer_relax_limit_up = 1, multilayer_relax_limit_down = 0, temporal_network = F)
modules_relax_rate$modules$relax_rate <- r
relaxrate_modules <- rbind(relaxrate_modules, modules_relax_rate$modules)
}
write.csv(relaxrate_modules, "./R/Extra_analysis_results/relax_empirical.csv", row.names = FALSE)
#Plot number of modules according to relax rate
N_modules_relax <- relaxrate_modules %>%
group_by(relax_rate) %>% summarise(Num_modules = max(module))
N_modules_relax_empirical<- ggplot(N_modules_relax, aes(x = relax_rate, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+scale_y_continuous(limits= c(0,90),breaks=seq(0,90,10))+
labs(x='Relax rate', y="Number of modules")+ theme(axis.text.x = element_text(size=13),
axis.text.y=element_text(size=13), axis.title = element_text(size=15))
N_modules_relax_empirical
#Inter
dryad_multilayer_complete_fixed_output <- read.csv("inter_empirical.csv")
#Plot number of modules according to interedges values
N_modules_inter <- dryad_multilayer_complete_fixed_output %>%
group_by(trial_num) %>% summarise(Num_modules = max(module)) %>% rename(inter_edges = 1)
N_modules_inter_empirical<- ggplot(N_modules_inter, aes(x = inter_edges, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+ scale_y_continuous(breaks=seq(0,90,10))+
labs(x='Interedges', y="Number of modules")+ theme(axis.text.x = element_text(size=13),
axis.text.y=element_text(size=13), axis.title = element_text(size=15))
#Relax rate
relaxrate_modules <- read.csv("relax_empirical.csv")
#Plot number of modules according to relax rate
N_modules_relax <- relaxrate_modules %>%
group_by(relax_rate) %>% summarise(Num_modules = max(module))
N_modules_relax_empirical<- ggplot(N_modules_relax, aes(x = relax_rate, y = Num_modules)) +  geom_bar(stat= "identity")+
theme_classic() +  scale_x_continuous(breaks=seq(0.1,1,0.1))+scale_y_continuous(limits= c(0,90),breaks=seq(0,90,10))+
labs(x='Relax rate', y="Number of modules")+ theme(axis.text.x = element_text(size=13),
axis.text.y=element_text(size=13), axis.title = element_text(size=15))
#Plot together  (ver si hacer grafico de distribucion)
plot_grid(N_modules_inter_empirical,
N_modules_relax_empirical,
nrow = 2)
View(layer_metadata)
interactions_co_occurences <-read.csv("interactions_co_occurences.csv")
interactions_co_occurences <-read.csv("interactions_co_occurences.csv")
interactions_co_occurences_pot <- interactions_co_occurences %>%
mutate(possible_changes = co_occurrences - interactions) %>%
summarise(co_occurrences = sum (co_occurrences), interactions = sum(interactions), possible_changes = sum(possible_changes)) %>%
mutate(Id = c(1))
View(interactions_co_occurences_pot)
interactions_co_occurences <-read.csv("interactions_co_occurences.csv")
View(interactions_co_occurences)
interactions_co_occurences <-read.csv("co_occurrence_count.csv")
View(interactions_co_occurences)
View(interactions_co_occurences)
##----get_data--------------------------------------------------------------------------------------------------------
setwd("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands")
source("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands/R/functions.R")
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
dryad_edgelist_complete_ids <- read.csv("./csvs/Islands/dryad_edgelist_complete_ids_islands.csv")
#---- number of layers each species is found in------------------------------------------------------
#plants
plant_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_from <= 39) %>% select(layer_from, node_from) #one directed for this purpose, only plants
plant_half <- plant_half %>% unique() #remove doubles created due to aggregation
plant_half$count <- 1
plant_half <- plant_half %>% group_by(node_from) %>% mutate(number_of_layers = sum(count)) #count number of layers
#pollinators
pollinator_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_to > 39) %>% select(layer_from, node_to) #one directed for this purpose, only plants
pollinator_half <- pollinator_half %>% unique() #remove doubles created due to aggregation
pollinator_half$count <- 1
pollinator_half <- pollinator_half %>% group_by(node_to) %>% mutate(number_of_layers = sum(count)) #count number of layers
#---- pairs of plant-pollinator------------------------------------------------------------------------
#only plants found in >1 sites
plant_half_for_pairs <- plant_half %>% filter(number_of_layers > 1)
#only pollinators found in >1 sites
pollinator_half_for_pairs <- pollinator_half %>% filter(number_of_layers > 1)
#----number of times species interacted--------------------------------------------------------------
dryad_edgelist_one_sided <- dryad_edgelist_complete_ids %>% filter(node_from <= 39) #make sure we don't have double the results
interaction_count <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
interaction_count <- interaction_count %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
interaction_count$count <- 1 #add count we can sum later
interaction_count <- aggregate(count ~ node_from + node_to, interaction_count, FUN = sum) #count number of times nodes interacted
interaction_count <- rename(interaction_count, interactions = count) #rename to have distinct name
#----number of times species co-occurred--------------------------------------------------------------
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
View(co_occurrence)
#----number of times species interacted--------------------------------------------------------------
dryad_edgelist_one_sided <- dryad_edgelist_complete_ids %>% filter(node_from <= 39) #make sure we don't have double the results
interaction_count <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
interaction_count <- interaction_count %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
interaction_count$count <- 1 #add count we can sum later
interaction_count <- aggregate(count ~ node_from + node_to, interaction_count, FUN = sum) #count number of times nodes interacted
interaction_count <- rename(interaction_count, interactions = count) #rename to have distinct name
#----number of times species co-occurred--------------------------------------------------------------
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
View(co_occurrence)
i=2
current_plant_interactions <- co_occurrence %>% filter(node_from == i) #focal point is plants
unique_partners <- current_plant_interactions %>% select(node_from, node_to) %>% unique()
View(unique_partners)
##---load_libraries-------------------------------------------------------------------------------------------------
options(rgl.useNULL = TRUE)
library(infomapecology)
library(igraph)
library(bipartite)
library(tidyverse)
library(magrittr)
library(betalink)
library(readxl)
library(ggalluvial)
library(scatterpie)
library(reshape2)
library(ggforce)
library(ggmap)
library(ggraph)
library(ggtree)
library(ggpubr)
##----get_data--------------------------------------------------------------------------------------------------------
setwd("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands")
source("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands/R/functions.R")
physical_nodes <- read.csv("./csvs/Islands/physical_nodes_islands.csv")
layer_metadata <- read.csv("./csvs/Islands/layer_metadata_islands.csv")
dryad_edgelist_complete_ids <- read.csv("./csvs/Islands/dryad_edgelist_complete_ids_islands.csv")
#---- number of layers each species is found in------------------------------------------------------
#plants
plant_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_from <= 39) %>% select(layer_from, node_from) #one directed for this purpose, only plants
plant_half <- plant_half %>% unique() #remove doubles created due to aggregation
plant_half$count <- 1
plant_half <- plant_half %>% group_by(node_from) %>% mutate(number_of_layers = sum(count)) #count number of layers
#pollinators
pollinator_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_to > 39) %>% select(layer_from, node_to) #one directed for this purpose, only plants
pollinator_half <- pollinator_half %>% unique() #remove doubles created due to aggregation
pollinator_half$count <- 1
pollinator_half <- pollinator_half %>% group_by(node_to) %>% mutate(number_of_layers = sum(count)) #count number of layers
#---- pairs of plant-pollinator------------------------------------------------------------------------
#only plants found in >1 sites
plant_half_for_pairs <- plant_half %>% filter(number_of_layers > 1)
#only pollinators found in >1 sites
pollinator_half_for_pairs <- pollinator_half %>% filter(number_of_layers > 1)
#----number of times species interacted--------------------------------------------------------------
dryad_edgelist_one_sided <- dryad_edgelist_complete_ids %>% filter(node_from <= 39) #make sure we don't have double the results
interaction_count <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
interaction_count <- interaction_count %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
interaction_count$count <- 1 #add count we can sum later
interaction_count <- aggregate(count ~ node_from + node_to, interaction_count, FUN = sum) #count number of times nodes interacted
interaction_count <- rename(interaction_count, interactions = count) #rename to have distinct name
View(interaction_count)
#----number of times species co-occurred--------------------------------------------------------------
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
View(co_occurrence)
layer_1<- co_occurrence %>% filter(node_from == node_from, layer_from==1, layer_to==2)
View(layer_1)
layer_1<- co_occurrence %>% filter( layer_from==1, layer_to==2)
View(layer_1)
layer_1<- co_occurrence %>% filter(layer_from=1, layer_to=2)
#plants
plant_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_from <= 39) %>% select(layer_from, node_from) #one directed for this purpose, only plants
plant_half <- plant_half %>% unique() #remove doubles created due to aggregation
plant_half$count <- 1
plant_half <- plant_half %>% group_by(node_from) %>% mutate(number_of_layers = sum(count)) #count number of layers
#pollinators
pollinator_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_to > 39) %>% select(layer_from, node_to) #one directed for this purpose, only plants
pollinator_half <- pollinator_half %>% unique() #remove doubles created due to aggregation
pollinator_half$count <- 1
pollinator_half <- pollinator_half %>% group_by(node_to) %>% mutate(number_of_layers = sum(count)) #count number of layers
#---- pairs of plant-pollinator------------------------------------------------------------------------
#only plants found in >1 sites
plant_half_for_pairs <- plant_half %>% filter(number_of_layers > 1)
#only pollinators found in >1 sites
pollinator_half_for_pairs <- pollinator_half %>% filter(number_of_layers > 1)
#----number of times species interacted--------------------------------------------------------------
dryad_edgelist_one_sided <- dryad_edgelist_complete_ids %>% filter(node_from <= 39) #make sure we don't have double the results
interaction_count <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
interaction_count <- interaction_count %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
interaction_count$count <- 1 #add count we can sum later
interaction_count <- aggregate(count ~ node_from + node_to, interaction_count, FUN = sum) #count number of times nodes interacted
interaction_count <- rename(interaction_count, interactions = count) #rename to have distinct name
#----number of times species co-occurred--------------------------------------------------------------
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
layer_1<- co_occurrence %>% filter(layer_from !==layer_to)
layer_1<- co_occurrence %>% filter(layer_from !=layer_to)
View(co_occurrence)
View(layer_1)
layer_1<- co_occurrence %>% filter(layer_from ==layer_to)
layer_1<- co_occurrence %>% filter(layer_from !==layer_to)
layer_1<- co_occurrence %>% filter(layer_from !=layer_to)
View(co_occurrence)
#plants
plant_half <- dryad_edgelist_complete_ids %>% filter(layer_from != layer_to) %>% #take only intralayers
filter(node_from <= 39) %>% select(layer_from, node_from) #one directed for this purpose, only plants
plant_half <- plant_half %>% unique() #remove doubles created due to aggregation
plant_half$count <- 1
plant_half <- plant_half %>% group_by(node_from) %>% mutate(number_of_layers = sum(count)) #count number of layers
#pollinators
pollinator_half <- dryad_edgelist_complete_ids %>% filter(layer_from == layer_to) %>% #take only intralayers
filter(node_to > 39) %>% select(layer_from, node_to) #one directed for this purpose, only plants
pollinator_half <- pollinator_half %>% unique() #remove doubles created due to aggregation
pollinator_half$count <- 1
pollinator_half <- pollinator_half %>% group_by(node_to) %>% mutate(number_of_layers = sum(count)) #count number of layers
#---- pairs of plant-pollinator------------------------------------------------------------------------
#only plants found in >1 sites
plant_half_for_pairs <- plant_half %>% filter(number_of_layers > 1)
#only pollinators found in >1 sites
pollinator_half_for_pairs <- pollinator_half %>% filter(number_of_layers > 1)
#----number of times species interacted--------------------------------------------------------------
dryad_edgelist_one_sided <- dryad_edgelist_complete_ids %>% filter(node_from <= 39) #make sure we don't have double the results
interaction_count <- dryad_edgelist_one_sided %>% filter(layer_from == layer_to) #only intra as we need just pollination interactions to change
interaction_count <- interaction_count %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
interaction_count$count <- 1 #add count we can sum later
interaction_count <- aggregate(count ~ node_from + node_to, interaction_count, FUN = sum) #count number of times nodes interacted
interaction_count <- rename(interaction_count, interactions = count) #rename to have distinct name
#----number of times species co-occurred--------------------------------------------------------------
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_one_sided %>% filter(layer_from != layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
View(co_occurrence)
View(co_occurrence)
View(co_occurrence)
co_occurrence_count <- NULL
co_occurrence <- dryad_edgelist_complete_ids %>% filter(layer_from != layer_to) #only intra as we need just pollination interactions to change
co_occurrence <- co_occurrence %>% select(layer_from, node_from, layer_to, node_to) %>% unique() #remove doubles created due to aggregation
View(co_occurrence)
layer1_2<- co_occurrence %>% filter(layer_from==1, layer_to==2)
View(layer1_2)
layer1_2<- co_occurrence %>% filter(layer_from==1, layer_to==2) %>% count()
View(layer1_2)
layer1_3<- co_occurrence %>% filter(layer_from==1, layer_to==3) %>% count()
View(layer1_3)
layer1_4<- co_occurrence %>% filter(layer_from==1, layer_to==4) %>% count()
View(layer1_4)
layer1_5<- co_occurrence %>% filter(layer_from==1, layer_to==5) %>% count()
View(layer1_5)
layer1_6<- co_occurrence %>% filter(layer_from==1, layer_to==6) %>% count()
View(layer1_6)
layer1_7<- co_occurrence %>% filter(layer_from==1, layer_to==7) %>% count()
View(layer1_7)
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==1) %>% count()
View(layer2_1)
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==1) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==3) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==4) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==5) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==6) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==2, layer_to==7) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==3, layer_to==4) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==3, layer_to==5) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==3, layer_to==6) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==3, layer_to==7) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==4, layer_to==5) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==4, layer_to==6) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==4, layer_to==7) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==5, layer_to==6) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==5, layer_to==7) %>% count() %>% print()
layer2_1<- co_occurrence %>% filter(layer_from==6, layer_to==7) %>% count() %>% print()
library(knitr)
Description <- read_excel("Location_description.xlsx", sheet = 3)
kable(Description, align=c(rep('c',times=7)))
Description <- read_excel("Location_description.xlsx", sheet = 3)
library(knitr)
Description <- read_excel("Location_description.xlsx", sheet = 3)
library(knitr)
Description <- read_excel("Location_description.xlsx", sheet = 3)
kable(Description)
library(knitr)
Description <- read_excel("Location_description.xlsx", sheet = 3)
kable(Description, align=c(rep('c',times=8))
library(knitr)
Description <- read_excel("Location_description.xlsx", sheet = 3)
kable(Description, align=c(rep('c',times=8)))

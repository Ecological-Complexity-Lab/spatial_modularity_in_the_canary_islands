theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))
islands_turnover_with_distnace_empirical <- read.csv("islands_turnover_with_distnace_empirical.csv")
islands_turnover_with_distnace_empirical %>%
ggplot(aes(x=distance_in_km, y=turnover))+
geom_point(color = "indianred2")+
scale_x_continuous()+ stat_smooth(method= "lm", se=F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+ theme_bw()+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.36, 0.34, 0.32, 0.30))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
jaccard_similarity_layer_empirical_and_null_km <- read.csv("jaccard_similarity_layer_empirical_and_null_km_islands.csv")
jaccard_similarity_layer_empirical_and_null_km %>%
ggplot(aes(x= mean_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.60, 0.56, 0.52, 0.48))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) # stat_cor(aes(label = ..p.label..), label.x = 400)+
correlation_empirical_pols <- read.csv("correlation_empirical_pols_islands.csv")
rqsuares_M1_all <- read.csv("rqsuares_M1_all_islands.csv")
group_color <- c(shuf_pollinators = "#BE75FA",
shuf_plants = "#15B7BC",
shuf_both = "#72A323")
rqsuares_M1_all %>%
ggplot(aes(x = rsquared, fill = type))+
geom_density(alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_pols$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())+
scale_fill_manual(values = group_color)
jaccard_similarity_layer_empirical_and_null_km  <- read.csv("jaccard_similarity_layer_empirical_and_null_km_islands.csv")
jaccard_similarity_layer_empirical_and_null_km %>%
ggplot(aes(x= mean_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+
stat_cor(aes(label = after_stat(rr.label)), label.x = 400, label.y = c(0.60, 0.56, 0.52, 0.48))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)
#distribution of rsquared and add empirical
correlation_empirical_interactions <- read.csv("correlation_empirical_interactions_islands.csv")
iteration_correlation_interactions <- read.csv("iteration_correlation_interactions_islands.csv")
iteration_correlation_interactions %>% ggplot(aes(x = rsquared))+
geom_density(fill = "#0033cc", color = "#0033cc", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
##compare both parts of beta diversity (shuffling pollinator species )
iteration_correlation_pols <- read.csv("iteration_correlation_pols_islands.csv")
iteration_correlation_interactions <- read.csv("iteration_correlation_interactions_islands.csv")
correlation_empirical_interactions <- read.csv("correlation_empirical_interactions_islands.csv")
interactions_for_beta_diversity <- iteration_correlation_interactions
interactions_for_beta_diversity$type <- "shuffling_interactions"
species_for_beta_diversity <- iteration_correlation_pols
species_for_beta_diversity$type <- "shuffling_species"
correlation_beta_diversity <- rbind(interactions_for_beta_diversity, species_for_beta_diversity)
correlation_beta_diversity %>% ggplot(aes(x = rsquared, color = type, fill = type))+ #overlay shuffling of interactions and species
geom_density(alpha = 0.4)+ scale_color_manual(values = c("#0033cc", "#BE75FA"))+
scale_fill_manual(values = c("#0033cc", "#BE75FA"))+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical_interactions$rsquared, linetype = "dashed", color = "#F47069")
jaccard_similarity_empirical_and_fixed_no_self_loop_km<- read.csv("jaccard_similarity_empirical_and_fixed_no_self_loop_km_islands.csv")
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank()) + stat_cor(aes(label = ..p.label..), label.x = 400)+
stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))
##---load_libraries-------------------------------------------------------------------------------------------------
options(rgl.useNULL = TRUE)
library(infomapecology)
library(igraph)
library(bipartite)
library(tidyverse)
library(magrittr)
library(betalink)
library(readxl)
library(ggalluvial)
library(scatterpie)
library(reshape2)
library(ggforce)
library(ggmap)
library(ggraph)
library(ggpubr)
##----get_data--------------------------------------------------------------------------------------------------------
setwd("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands")
source("/Users/agustin/Desktop/Papers/Canary_Island_Project/spatial_modularity_in_the_canary_islands/R/functions.R")
##---- Distance decay of modules  ---------------------------------------------------------------
distances_with_ids <- read.csv("./csvs/Islands/distances_with_ids_islands_as_layers.csv")
#write.csv(dryad_multilayer_shuf_1000_pols_output, "./csvs/Islands/Jac/dryad_multilayer_shuf_1000_pols_output_islands_as_layers.csv", row.names = FALSE)
#write.csv(dryad_multilayer_shuf_1000_plants_output, "./csvs/Islands/Jac/dryad_multilayer_shuf_1000_plants_output_islands_as_layers.csv", row.names = FALSE)
#write.csv(dryad_multilayer_shuf_1000_both_output, "./csvs/Islands/Jac/dryad_multilayer_shuf_1000_both_output_islands_as_layers.csv", row.names = FALSE)
dryad_multilayer_shuf_1000_pols_output <- read.csv("./csvs/Islands/Jac/dryad_multilayer_shuf_1000_pols_output_islands_as_layers.csv")
#pivot modules function for islands as layers
pivot_by_module_islands <- function(data){ #creates a data frame with module on the side and layer_id on the top
s1 = melt( data, id = c("layer_id", "module"))
s2 = dcast(s1, layer_id ~ module, length)
s2<-na.omit(s2)
s3 <-s2%>%
select(where(~ any(. != 0)))
s4 = t(s3)
s4 <- s4[-1,]
colnames(s4) <- c(1,2,3,4,5,6,7)
return(s4)
}
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1:2){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf, tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace_per <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
edge_list_per_module_islands <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:6)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):7)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <-rbind(edge_list,tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
turnover_with_distance_pols <- NULL
turnover_with_distance_plants <- NULL
turnover_with_distance_both <- NULL
module_layer_turnover_shuf <- NULL
layers_turnover_with_distnace<-NULL
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
View(dryad_multilayer_shuf_1000_pols_output)
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf, tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace_per <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace_per <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
turnover_with_distance_pols <- NULL
turnover_with_distance_plants <- NULL
turnover_with_distance_both <- NULL
module_layer_turnover_shuf <- NULL
layers_turnover_with_distnace<-NULL
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
View(all_edge_list_layer_combine_no_module_shuf_pols_output)
for (trial in 1:2){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1:2){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
turnover_with_distance_pols <- NULL
turnover_with_distance_plants <- NULL
turnover_with_distance_both <- NULL
module_layer_turnover_shuf <- NULL
layers_turnover_with_distnace<-NULL
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
View(all_edge_list_layer_combine_no_module_shuf_pols_output)
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1:2){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf<-NULL
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
turnover_with_distance_pols <- NULL
turnover_with_distance_plants <- NULL
turnover_with_distance_both <- NULL
module_layer_turnover_shuf <- NULL
layers_turnover_with_distnace<-NULL
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
View(all_edge_list_layer_combine_no_module_shuf_pols_output)
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1:3){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
# this function calculates the Jaccard Similarity in modules between islands
module_distance_decay_islands_func <- function(multilayer_1000,
layers_turnover_with_distnace){
for (trial in 1:3){
print(trial) #to keep tab on how far along we are
modules_for_similarity_shuf <- multilayer_1000 %>% filter(trial_num ==trial) #take only 1 trial
#pivot modules
module_pivoted_shuf <- pivot_by_module_islands(modules_for_similarity_shuf) #pivot will be done on 1 trial each time
#create edge list with distances
modules_edge_list_shuf <- NULL
for (k in (1:nrow(module_pivoted_shuf))){ #run the function for each row in the data frame
modules_edge_list_shuf <- edge_list_per_module_islands(module_pivoted_shuf[k,], modules_edge_list_shuf)
current_module <- rownames(module_pivoted_shuf)[k]
if (is.null(modules_edge_list_shuf)) next
modules_edge_list_shuf <- modules_edge_list_shuf %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances_shuf <- right_join(modules_edge_list_shuf, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances_shuf <- na.omit(edge_list_with_distances_shuf) #we remove this line (which it removes NA), because we have a lot locations don't have modules in common
for (i in 1:6){
for (j in (i+1):7){
modules_in_layer_from_shuf <- filter(modules_for_similarity_shuf, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_shuf <- filter(modules_for_similarity_shuf, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all nodes in layer_from and all nodes in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_shuf, modules_in_layer_to_shuf) #how many nodes are found in both layers
uni_both <- union(modules_in_layer_from_shuf, modules_in_layer_to_shuf)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_shuf <- rbind(module_layer_turnover_shuf,
tibble(layer_from = i, layer_to = j, turnover = turnover, trial = trial))
}
}
layers_turnover_with_distnace <- edge_list_with_distances_shuf %>%
merge(module_layer_turnover_shuf, by= c("layer_from", "layer_to")) #merge both versions
}
return(layers_turnover_with_distnace)
}
#shuff pols
all_edge_list_layer_combine_no_module_shuf_pols_output <- module_distance_decay_islands_func(dryad_multilayer_shuf_1000_pols_output,
turnover_with_distance_pols)
comb<-all_edge_list_layer_combine_no_module_shuf_pols_output %>% arrange(trial)
View(comb)

}
arguments <- ifelse(!is.null(multilayer_relax_rate),
paste(arguments, "--multilayer-relax-rate", multilayer_relax_rate),
arguments)
arguments <- ifelse(!is.null(multilayer_relax_limit),
paste(arguments, "--multilayer-relax-limit", multilayer_relax_limit),
arguments)
arguments <- ifelse(!is.null(multilayer_relax_limit_up),
paste(arguments, "--multilayer-relax-limit-up", multilayer_relax_limit_up),
arguments)
arguments <- ifelse(!is.null(multilayer_relax_limit_down),
paste(arguments, "--multilayer-relax-limit-down",
multilayer_relax_limit_down), arguments)
}
call <- paste("./", infomap_executable, " infomap_multilayer.txt . ",
arguments, sep = "")
if (run_standalone == T) {
print(call)
system(call)
}
else {
print("Please run Infomap online at https://www.mapequation.org/infomap/ using the following arguments (copy-paste):")
print(arguments)
invisible(readline(prompt = "After running, download statenodes results and press [ENTER] when done"))
if (!file.exists("network_states.tree")) {
stop("Result file network_states.tree was not found. Did you download results?")
}
file.rename(from = "network_states.tree", to = "infomap_multilayer_states.tree")
}
L_output <- parse_number(read_lines("infomap_multilayer_states.tree")[6])
modules <- suppressMessages(read_delim("infomap_multilayer_states.tree",
delim = " ", skip = 11, col_names = c("path", "flow",
"name", "state_id", "node_id", "layer_id")))
modules %<>% filter(flow > 0) %>% dplyr::select(path, node_id, layer_id,
flow) %>% separate(path, into = c("module", "leaf_id"),
sep = ":") %>% mutate_at(.vars = 1:4, as.integer) %>%
full_join(M$nodes, "node_id") %>% dplyr::select(node_id, starts_with("module"),
everything(), -leaf_id) %>% dplyr::arrange(node_id, layer_id)
if (temporal_network) {
print("Reorganizing modules...")
renamed_moduels <- modules %>% distinct(module, layer_id) %>%
arrange(module, layer_id)
x <- c(1, table(renamed_moduels$module))
module_birth_layers <- renamed_moduels %>% slice(cumsum(x)) %>%
arrange(layer_id, module)
module_renaming <- data.frame(module = module_birth_layers$module,
module_renamed = 1:max(module_birth_layers$module))
modules %<>% left_join(module_renaming, "module") %>%
dplyr::select(-module) %>% rename(module = module_renamed)
}
if (remove_auxilary_files) {
print("Removing auxilary files...")
file.remove("infomap_multilayer_states.tree")
file.remove("infomap_multilayer.txt")
file.remove("infomap_multilayer.tree")
}
print(paste("Partitioned into ", max(modules$module), " modules.",
sep = ""))
out <- list(call = call, L = L_output, m = max(modules$module),
modules = modules)
class(out) <- "infomap_multilayer"
return(out)
}
getwd()
setwd("/Users/golds/Desktop/spatial_modularity_in_the_canary_islands")
inter_extended <- read.csv("./csvs/dryad_only_interlayer_edges.csv")
intra_nonextended <- read.csv("./csvs/dryad_only_intralayer_edges.csv")
physical_nodes <- read.csv("./csvs/physical_nodes.csv")
layer_metadata <-read.csv("./csvs/layer_metadata.csv")
interlayer_edges_change <- select(inter_extended, -weight) #create data frame where weight doesn't exist
interlayer_edges_change$weight <- 0.357602 #set fixed interlayer value to median of interlayer distribution
dryad_multilayer_fixed <- create_multilayer_object(intra = intra_nonextended,
inter = interlayer_edges_change, #create multilayer with new fixed inter value
nodes = physical_nodes,
layers = layer_metadata,
intra_output_extended = T)
interlayer_edges_change
intra_nonextended
dryad_intralayer <- read.csv("./csvs/intralayer_file.csv")
#print(dryad_intralayer)
dryad_interlayer <- read.csv("./csvs/interlayer_file.csv") #already has inverted within
#print(dryad_interlayer)
## ----multilayer_intra-----------------------------------------------------------------------------------------------
dryad_matrices <- NULL
for (layer in 1:14){
d <- suppressMessages(read_excel('all_sites.xlsx', sheet = layer+2))
web <- data.matrix(d[,2:ncol(d)])
rownames(web) <- as.data.frame(d)[,1]
web[is.na(web)] <- 0
dryad_matrices[[layer]] <- web
}
library(readxl)
dryad_intralayer <- read.csv("./csvs/intralayer_file.csv")
#print(dryad_intralayer)
dryad_interlayer <- read.csv("./csvs/interlayer_file.csv") #already has inverted within
#print(dryad_interlayer)
## ----multilayer_intra-----------------------------------------------------------------------------------------------
dryad_matrices <- NULL
for (layer in 1:14){
d <- suppressMessages(read_excel('all_sites.xlsx', sheet = layer+2))
web <- data.matrix(d[,2:ncol(d)])
rownames(web) <- as.data.frame(d)[,1]
web[is.na(web)] <- 0
dryad_matrices[[layer]] <- web
}
names_dryad_matrices <- c("WesternSahara1", "WesternSahara2", "Fuerteventura1", "Fuerteventura2",
"GranCanaria1", "GranCanaria2", "TenerifeSouth1", "TenerifeSouth2",
"TenerifeTeno1", "TenerifeTeno2",  "Gomera1", "Gomera2", "Hierro1", "Hierro2")
# Layer dimensions
sapply(dryad_matrices, dim)
intralayer_inverted <- tibble(values= dryad_intralayer$layer_to, dryad_intralayer$node_to, dryad_intralayer$layer_from,
dryad_intralayer$node_from, dryad_intralayer$weight) #create an inverted copy for directed intralayers
colnames(intralayer_inverted) <- c("layer_from", "node_from", "layer_to", "node_to", "weight")
tot_plant <- dryad_intralayer %>%
group_by(layer_from,node_from) %>%
dplyr::summarise(tot=sum(weight))
intralayer_weighted <- dryad_intralayer %>% left_join(tot_plant) %>% mutate(rel_weight=weight/tot) %>%
select(-weight,-tot) %>% dplyr::rename(weight=rel_weight)
#pols in from
tot_pol <- intralayer_inverted %>%
group_by(layer_from,node_from) %>%
dplyr::summarise(tot=sum(weight))
intralayer_weighted_inverted <- intralayer_inverted %>% left_join(tot_pol) %>% mutate(rel_weight=weight/tot) %>%
select(-weight,-tot) %>% dplyr::rename(weight=rel_weight)
## ----multilayer_extended_final--------------------------------------------------------------------------------------
edgelist_intralayers_both <- bind_rows(intralayer_weighted, intralayer_weighted_inverted) #combine weighted version of intra with inter
dryad_edgelist_complete <- bind_rows(edgelist_intralayers_both, dryad_interlayer) #combine inverted and non inverted verions
# Distribution of edge weights
dryad_edgelist_complete %>%
mutate(edge_type=ifelse(layer_from==layer_to,'Intra','Inter')) %>% #if same species in to and from edge_type is intra else it's inter
ggplot()+
geom_histogram(aes(x=weight, fill=edge_type), alpha=0.6)+ #create histogram of edge_type and weight
facet_wrap(~layer_from, scales = 'free')+ #create multi-panel plot aligning by layer_from
scale_fill_manual(values = c('navy','plum'))+theme_classic()
## ----node_metadata--------------------------------------------------------------------------------------------------
pollinators <- sort(unique(intralayer_weighted$node_to)) #adding up only pol who haven't been added yet
plants <- sort(unique(intralayer_weighted$node_from)) #adding up only plants who haven't been added yet
intersect(pollinators, plants) #making sure I don't have plants in pol or other way around
A <- length(pollinators) # Number of pollinators
P <- length(plants) # Number of plants
S <- A+P
physical_nodes <- tibble(node_id=1:S, #1 till the last species
type=c(rep('plant',P),rep('pollinator',A)), #replicate the words P and A times
species=c(plants,pollinators)) #add species from plants and pollinators in accordance
layer_metadata <- tibble(layer_id=c(1:14), layer_name=names_dryad_matrices)  #give num to each layer
dryad_edgelist_complete_ids <-
dryad_edgelist_complete %>%
left_join(physical_nodes, by=c('node_from' = 'species')) %>%  # Join for pollinators
left_join(physical_nodes, by=c('node_to' = 'species')) %>%  # Join for plants
dplyr::select(-node_from, -node_to) %>% #choose said columns
dplyr::select(layer_from, node_from=node_id.x, layer_to, node_to=node_id.y, weight) %>%
left_join(layer_metadata, by=c('layer_from' = 'layer_name')) %>%  # Join for plants
left_join(layer_metadata, by=c('layer_to' = 'layer_name')) %>%  # Join for plants
dplyr::select(-layer_from, -layer_to) %>%
dplyr::select(layer_from=layer_id.x, node_from, layer_to=layer_id.y, node_to, weight)
#write.csv(dryad_edgelist_complete_ids, "./csvs/dryad_edgelist_complete_ids.csv", row.names = FALSE)
dryad_multilayer <- create_multilayer_object(extended = dryad_edgelist_complete_ids, #taking edge list and returning multilayer network
nodes = physical_nodes,
layers = layer_metadata,
intra_output_extended = T)
# Input: intra non-extended
intra_nonextended <-
dryad_edgelist_complete_ids %>%
filter(layer_from==layer_to) %>% #only intra
dplyr::select(layer=layer_from, node_from, node_to, weight)
inter_extended <-
dryad_edgelist_complete_ids %>%
filter(layer_from!=layer_to) #only inter
write.csv(intra_nonextended, "./csvs/dryad_only_intralayer_edges.csv", row.names = FALSE)
write.csv(inter_extended, "./csvs/dryad_only_interlayer_edges.csv", row.names = FALSE)
#inter_extended <- read.csv("./csvs/dryad_only_interlayer_edges.csv")
interlayer_edges_change <- select(inter_extended, -weight) #create data frame where weight doesn't exist
interlayer_edges_change$weight <- 0.357602 #set fixed interlayer value to median of interlayer distribution
dryad_multilayer_fixed <- create_multilayer_object(intra = intra_nonextended,
inter = interlayer_edges_change, #create multilayer with new fixed inter value
nodes = physical_nodes,
layers = layer_metadata,
intra_output_extended = T)
modules_edge_change_fixed <- modified_multi(dryad_multilayer_fixed,
infomap_executable = "../Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294,
temporal_network = F)
modules_edge_change_fixed <- modified_multi(dryad_multilayer_fixed,
infomap_executable = "Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294,
temporal_network = F)
modules <- read.csv('./csvs/modules_dryad_multilayer.csv')
modules_fixed <- modules_edge_change_fixed$modules #39 modules
## empirical
#modules <- read.csv('./csvs/modules_dryad_multilayer.csv')
modules_dryad_multilayer_fixed_analysis <- modules #create version just for the analysis
pivot_by_module <- function(data){ #creates a data frame with module on the side and layer_id on the top
s1 = melt(data, id = c("layer_id", "module"))
s2 = dcast(s1, layer_id ~ module, length)
s3 = t(s2)
s3 <- s3[-1,]
colnames(s3) <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
return(s3)
}
#get module_sub_module for both fixed and empirical multi lvl
module_pivoted_fixed <- pivot_by_module(modules_fixed) #pivot for fixed
library(reshape2)
module_pivoted_fixed <- pivot_by_module(modules_fixed) #pivot for fixed
module_pivoted_empirical_fixed_analysis <- pivot_by_module(modules_dryad_multilayer_fixed_analysis) #pivot for empirical
##---- edge list per module
# this function creates an edge list of layers found in a module with distances
edge_list_per_module <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:13)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):14)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
modules_edge_list_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_fixed))){ #run the function for each row in the data frame
modules_edge_list_fixed_analysis <- edge_list_per_module(module_pivoted_fixed[k,], modules_edge_list_fixed_analysis)
current_module_fixed <- rownames(module_pivoted_fixed)[k]
if (is.null(modules_edge_list_fixed_analysis)) next
modules_edge_list_fixed_analysis <- modules_edge_list_fixed_analysis %>% mutate(module = replace_na(module, current_module_fixed)) #add module number
}
modules_edge_list_empirical_fixed_analysis <- NULL
for (k in (1:nrow(module_pivoted_empirical_fixed_analysis))){ #run the function for each row in the data frame
modules_edge_list_empirical_fixed_analysis <- edge_list_per_module(module_pivoted_empirical_fixed_analysis[k,], modules_edge_list_empirical_fixed_analysis)
current_module_empirical <- rownames(module_pivoted_empirical_fixed_analysis)[k]
if (is.null(modules_edge_list_empirical_fixed_analysis)) next
modules_edge_list_empirical_fixed_analysis <- modules_edge_list_empirical_fixed_analysis %>% mutate(module = replace_na(module, current_module_empirical)) #add module number
}
edge_list_with_distances_fixed <- right_join(modules_edge_list_fixed_analysis, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
edge_list_by_islands_modules_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters)) #maybe do it differently? should i make all distances within the same island 0?
distances_with_ids <- read.csv("./csvs/distances_with_ids.csv")
edge_list_with_distances_fixed <- right_join(modules_edge_list_fixed_analysis, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
edge_list_with_distances_fixed <- na.omit(edge_list_with_distances_fixed) #remove NA and delete layer name
edge_list_by_islands_modules_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters)) #maybe do it differently? should i make all distances within the same island 0?
edge_list_by_islands_modules_fixed$count <- c(1)
edge_list_by_islands_modules_fixed <- edge_list_by_islands_modules_fixed %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, layer_to, module, number_of_modules)
edge_list_by_islands_modules_fixed
edge_list_by_layer_modules_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters)) #maybe do it differently? should i make all distances within the same island 0?
edge_list_by_islands_modules_fixed$count <- c(1)
edge_list_by_islands_modules_fixed <- edge_list_by_islands_modules_fixed %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, laye
edge_list_by_layer_ave_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to) %>%
#version with # of modules in layers
edge_list_by_layer_modules_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters)) #maybe do it differently? should i make all distances within the same island 0?
edge_list_by_islands_modules_fixed$count <- c(1)
edge_list_by_islands_modules_fixed <- edge_list_by_islands_modules_fixed %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, layer_to, module, number_of_modules)
edge_list_by_layer_ave_fixed <- edge_list_with_distances_fixed %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(distance_in_meters)) %>% unique()
edge_list_layer_combine_fixed <- edge_list_by_layer_ave_fixed %>%
merge(edge_list_by_layer_modules_fixed, by= c("layer_from", "layer_to")) #merge both versions
edge_list_layer_combine_no_module_fixed_analysis <- edge_list_layer_combine_fixed %>% select(-module) %>% unique() #have version where modules aren't present
edge_list_by_islands_modules_fixed
size <- count(modules_edge_change_fixed$modules, module)  #create a data frame of all modules and how many nodes are in each (size of module)
module_data <- merge(modules_edge_change_fixed$modules , size, by=c("module","module")) #merge size of module with all the other info about the modules
colnames(module_data)[7] <- "size_of_module" #rename column
lon_lat_data <- read_csv('./csvs/layers.csv') #create new data frame with just the layer data
lon_lat_data <- lon_lat_data %>% select(c("layer_id","lat","Lon")) %>% na.omit()  #only select layer id and coordinates
module_data_with_loc <- merge(module_data, lon_lat_data, by= c("layer_id","layer_id")) #merge modules with module size with the coordinates
modules_with_lat_lon <- module_data_with_loc %>% select(layer_id, module, lat, Lon, size_of_module) %>% unique() #take only certain columns
modules_with_lat_lon$count <- c(1)
write.csv(modules_with_lat_lon, "csvs/modules_with_lat_lon_fixed.csv", row.names = FALSE)
modules_with_lat_lon
#here!
module_layer_turnover_fixed_analysis <- NULL
#island_list <- c("1","2","3","4east","4west","5","6")
for (i in 1:14){
for (j in 1:14){
modules_in_layer_from_fixed_analysis <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_fixed_analysis <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_island_from_fixed_analysis, modules_in_island_to_fixed_analysis) #how many sub modules are common in both layers
uni_both <- union(modules_in_island_from_fixed_analysis, modules_in_island_to_fixed_analysis) #how many sub modules are found in both layers in total
turnover <- length(int_both)/length(uni_both)
module_island_turnover_fixed_analysis <- rbind(module_island_turnover_fixed_analysis, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
# total number of modules in each layer
module_layer_turnover_fixed_analysis <- NULL
#island_list <- c("1","2","3","4east","4west","5","6")
for (i in 1:14){
for (j in 1:14){
modules_in_layer_from_fixed_analysis <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_fixed_analysis <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_fixed_analysis, modules_in_layer_to_fixed_analysis) #how many sub modules are common in both layers
uni_both <- union(modules_in_layer_from_fixed_analysis, modules_in_layer_to_fixed_analysis) #how many sub modules are found in both layers in total
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_fixed_analysis <- rbind(module_layer_turnover_fixed_analysis, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_layer_turnover_fixed_analysis <- drop_na(module_layer_turnover_fixed_analysis)
edge_list_by_layer_ave_fixed <- edge_list_by_layer_fixed %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(distance_in_meters)) %>% unique()
layer_turnover_with_distnace_fixed <- edge_list_by_layer_ave_fixed %>%
merge(module_layer_turnover_fixed_analysis, by= c("layer_from", "layer_to")) #merge both versions
edge_list_with_distances_empirical <- right_join(modules_edge_list_empirical_fixed_analysis,
distances_with_ids, by= c("layer_from", "layer_to"))
edge_list_with_distances_empirical <- na.omit(edge_list_with_distances_empirical) #remove NA
edge_list_by_layer_modules_empirical <- edge_list_by_layer_empirical %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters))
edge_list_by_layer_modules_empirical <- edge_list_with_distances_empirical %>% group_by(layer_from, layer_to, module) %>%
summarise(ave_distance= mean(distance_in_meters))
edge_list_by_layer_modules_empirical$count <- c(1)
edge_list_by_layer_modules_empirical <- edge_list_by_layer_modules_empirical %>% mutate(number_of_modules= sum(count)) %>%
select(layer_from, layer_to, module, number_of_modules)
modules_with_lat_lon_empirical <- read.csv("csvs/modules_with_lat_lon.csv")
module_island_turnover_empirical <- NULL
#island_list <- c("1","2","3","4east","4west","5","6")
for (i in 1:14){
for (j in 1:14){
modules_in_layer_from_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis) #how many sub modules are found in both layers
uni_both <- union(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_empirical <- rbind(module_layer_turnover_empirical, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_layer_turnover_empirical <- NULL
#island_list <- c("1","2","3","4east","4west","5","6")
for (i in 1:14){
for (j in 1:14){
modules_in_layer_from_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis) #how many sub modules are found in both layers
uni_both <- union(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_empirical <- rbind(module_layer_turnover_empirical, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_island_turnover_empirical <- drop_na(module_island_turnover_empirical)
module_island_turnover_empirical
modules_with_lat_lon_empirical <- read.csv("csvs/modules_with_lat_lon.csv")
module_layer_turnover_empirical <- NULL
#island_list <- c("1","2","3","4east","4west","5","6")
for (i in 1:14){
for (j in 1:14){
modules_in_layer_from_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_layer_to_empirical_analysis <- filter(modules_with_lat_lon_empirical, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all sub modules in layer_from and all sub modules in layer_to to check turnover
int_both <- intersect(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis) #how many sub modules are found in both layers
uni_both <- union(modules_in_layer_from_empirical_analysis, modules_in_layer_to_empirical_analysis)
turnover <- length(int_both)/length(uni_both)
module_layer_turnover_empirical <- rbind(module_layer_turnover_empirical, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
module_layer_turnover_empirical
module_island_turnover_empirical <- drop_na(module_island_turnover_empirical)
module_layer_turnover_empirical <- drop_na(module_layer_turnover_empirical)
edge_list_by_layer_ave_empirical <- edge_list_by_layer_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(distance_in_meters)) %>% unique()
edge_list_with_distances_empirical
edge_list_by_layer_ave_empirical <- edge_list_with_distances_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave_distance= mean(distance_in_meters)) %>% unique()
layer_turnover_with_distnace_empirical <- edge_list_by_layer_ave_empirical %>%
merge(module_layer_turnover_empirical, by= c("layer_from", "layer_to")) #merge both versions
ave_module_layer_turnover_shuf_fixed <- layer_turnover_with_distnace_fixed %>%
group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(ave_distance)) %>% mutate(type="null_fixed") #create mean and sd for each point
empirical_turnover_for_module_layer_analysis <- layer_turnover_with_distnace_empirical %>% group_by(layer_from, layer_to) %>%
summarise(ave=mean(turnover), sd=sd(turnover), ave_dist=mean(ave_distance)) %>% mutate(type="empirical") #make sure sd is 0 cause its the empirical and not null
jaccard_similarity_empirical_and_fixed <- rbind(empirical_turnover_for_module_layer_analysis,
ave_module_layer_turnover_shuf_fixed)
jaccard_similarity_empirical_and_fixed_no_self_loop <- jaccard_similarity_empirical_and_fixed %>% subset(layer_from != layer_to)
jaccard_similarity_empirical_and_fixed_no_self_loop_km <- jaccard_similarity_empirical_and_fixed_no_self_loop %>%
mutate(ave_dist_in_km = ave_dist/1000)
jaccard_similarity_empirica_no_self_loop_km <- jaccard_similarity_empirical_and_fixed_no_self_loop_km %>%
filter(type == "empirical")
jaccard_similarity_empirica_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave))+
geom_point()+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.text = element_text(size = 13), legend.title = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")#+ stat_cor(aes(label = ..p.label..), label.x = 400)+
#stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))+ scale_color_manual(values = c("#F47069", "#c4ad06"))
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))
#+ stat_cor(aes(label = ..p.label..), label.x = 400)+
#stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))
view(jaccard_similarity_empirical_and_fixed_no_self_loop_km)
view(modules_with_lat_lon)
view(module_data)
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
#empirical and null
pdf('./graphs/uniform_intelayer_values/distance_decay_in_modules_M4.pdf', 10, 6)
pdf('./graphs/uniform_intelayer_values/distance_decay_in_modules_M4.pdf', 10, 6)
pdf('./graphs/uniform_interlayer_values/distance_decay_in_modules_M4.pdf', 10, 6)
jaccard_similarity_empirical_and_fixed_no_self_loop_km %>% ggplot(aes(x= ave_dist_in_km, y= ave, group= type, color= type))+
geom_point()+ geom_errorbar(aes(ymin= ave-sd, ymax= ave+sd))+ theme_classic()+ geom_smooth(method= "lm", se=F)+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+ theme(legend.title = element_text(size = 13), legend.text = element_text(size = 13))+
labs(x="Distance in Km", y="Jaccard Similarity")+ scale_color_manual(values = c("#F47069", "#c4ad06"))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
#+ stat_cor(aes(label = ..p.label..), label.x = 400)+
#stat_cor(aes(label = ..rr.label..), label.x = 400, label.y = c(0.65, 0.62))
dev.off()
layer_turnover_with_distnace_fixed
iteration_correlation_data_fixed <- layer_turnover_with_distnace_fixed %>% subset(layer_from != layer_to)
trial_fixed = iteration_correlation_data_fixed
iteration_correlation_new_fixed <- cor.test(trial_fixed$turnover, trial_fixed$ave_distance, method = "pearson")
lm_val_fixed <- lm(turnover ~ ave_distance, data = trial_fixed)
iteration_correlation_fixed <- tibble(estimate = iteration_correlation_new_fixed$estimate,
p_val = iteration_correlation_new_fixed$p.value,
statistic = iteration_correlation_new_fixed$statistic,
confidence_int_low = iteration_correlation_new_fixed$conf.int[1],
confidence_int_high = iteration_correlation_new_fixed$conf.int[2],
slope = lm_val_fixed$coefficients[2],
intercept = lm_val_fixed$coefficients[1],
rsquared = summary(lm_val_fixed)$adj.r.squared)
iteration_correlation_fixed
write.csv(iteration_correlation_fixed, "./csvs/iteration_correlation_fixed.csv", row.names = FALSE)
iteration_correlation_fixed <- read.csv("./csvs/iteration_correlation_fixed.csv")
correlation_empirical <- read.csv("./csvs/correlation_empirical_pols.csv")
rsquared_fixed <- iteration_correlation_fixed %>%
ggplot(aes(x = rsquared))+
geom_bar(fill = "#c4ad06", color = "#c4ad06", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
rsquared_fixed
rsquared_fixed <- iteration_correlation_fixed %>%
ggplot(aes(x = rsquared))+
geom_density(fill = "#c4ad06", color = "#c4ad06", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
rsquared_fixed
rsquared_fixed <- iteration_correlation_fixed %>%
ggplot(aes(x = rsquared))+
geom_bar(fill = "#c4ad06", color = "#c4ad06", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
rsquared_fixed
pdf('./graphs/uniform_interlayer_values/iteration_correlation_M4.pdf', 10, 6)
rsquared_fixed <- iteration_correlation_fixed %>%
ggplot(aes(x = rsquared))+
geom_bar(fill = "#c4ad06", color = "#c4ad06", alpha = 0.4)+
theme_classic()+ labs(x = "R squared")+
geom_vline(xintercept = correlation_empirical$rsquared, linetype = "dashed", color = "#F47069")+
theme(axis.title=element_text(size=22))+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
dev.off()
write.csv(jaccard_similarity_empirical_and_fixed_no_self_loop_km, "csvs/jaccard_similarity_empirical_and_fixed_no_self_loop_km.csv", row.names = FALSE)

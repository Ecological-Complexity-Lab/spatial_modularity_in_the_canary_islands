#inverted version
interlayer_inverted <- tibble(values= interlayers_with_weights_islands$layer_to, interlayers_with_weights_islands$node_to, interlayers_with_weights_islands$layer_from,
interlayers_with_weights_islands$node_from, interlayers_with_weights_islands$weight) #create an inverted copy for directed intralayers
colnames(interlayer_inverted) <- c("layer_from", "node_from", "layer_to", "node_to", "weight")
#Create interedgelist
edgelist_interlayers_both <- bind_rows(interlayers_with_weights_islands, interlayer_inverted) #combine inverted and non inverted versions of intra
## ----multilayer_extended_final--------------------------------------------------------------------------------------
dryad_edgelist_complete <- bind_rows(edgelist_intralayers_both, edgelist_interlayers_both) #combine weighted version of intra and interlayer links
## ----node_metadata--------------------------------------------------------------------------------------------------
pollinators <- sort(unique(intralayer_weighted$node_to)) #adding up only pol who haven't been added yet
plants <- sort(unique(intralayer_weighted$node_from)) #adding up only plants who haven't been added yet
intersect(pollinators, plants) #making sure I don't have plants in pol or other way around
A <- length(pollinators) # Number of pollinators
P <- length(plants) # Number of plants
S <- A+P
island_names <- c("Fuerteventura",#islands as layers
"GranCanaria",
"Tenerife",
"Gomera",
"Hierro")
# Create a table with node metadata
physical_nodes <- tibble(node_id=1:S, #1 till the last species
type=c(rep('plant',P),rep('pollinator',A)), #replicate the words P and A times
species=c(plants,pollinators)) #add species from plants and pollinators in accordance
layer_metadata <- tibble(layer_id=c(1:5), layer_name=island_names)  #give num to each layer
View(layer_metadata)
# Replace the node names with node_ids
dryad_edgelist_complete_ids <-
dryad_edgelist_complete %>%
left_join(physical_nodes, by=c('node_from' = 'species')) %>%  # Join for pollinators
left_join(physical_nodes, by=c('node_to' = 'species')) %>%  # Join for plants
dplyr::select(-node_from, -node_to) %>% #choose said columns
dplyr::select(layer_from, node_from=node_id.x, layer_to, node_to=node_id.y, weight) %>%
left_join(layer_metadata, by=c('layer_from' = 'layer_name')) %>%  # Join for plants
left_join(layer_metadata, by=c('layer_to' = 'layer_name')) %>%  # Join for plants
dplyr::select(-layer_from, -layer_to) %>%
dplyr::select(layer_from=layer_id.x, node_from, layer_to=layer_id.y, node_to, weight)
View(dryad_edgelist_complete_ids)
## ---- Multilayer_class to calculate modularity-----------------------------------------------------------------------------------------------
# Input: An extended edge list.
dryad_multilayer <- create_multilayer_object(extended = dryad_edgelist_complete_ids, #taking edge list and returning multilayer network
nodes = physical_nodes,
layers = layer_metadata,
intra_output_extended = T)
# Input: intra non-extended edge lists and inter extended edge list
intra_nonextended <-
dryad_edgelist_complete_ids %>%
filter(layer_from==layer_to) %>% #only intra
dplyr::select(layer=layer_from, node_from, node_to, weight)
inter_extended <-
dryad_edgelist_complete_ids %>%
filter(layer_from!=layer_to) #only inter
#calculate modules for empirical network
modules_dryad_multilayer <- modified_multi(dryad_multilayer,
infomap_executable = "Infomap",
flow_model = 'directed',
relax = F,
silent = T,
trials = 100,
seed = 497294,
temporal_network = F)
modules<-modules_dryad_multilayer$modules
distances <- read.csv("./csvs_nuevo/distances_file.csv", sep = ";")
View(distances)
## Calculate distances between islands (locations)-----
distances <- read.csv("./csvs_nuevo/distances_file.csv", sep = ";") %>%
filter(!(layer_from == "WesternSahara" |layer_to == "WesternSahara"))# keep just islands
# we recalculated the distance between each island and tenerife (after merging TenerifeSouth and TenerifeTeno)
distances_layer_from_to_tenerife<-distances %>% filter (layer_to == "TenerifeSouth" |layer_to == "TenerifeTeno") %>%
group_by(layer_from) %>% summarise(distance_in_meters = mean(distance_in_meters)) %>%
mutate(layer_to = "Tenerife") %>% filter(!(layer_from == "TenerifeSouth" |layer_from == "TenerifeTeno"))
distances_layer_from_to_tenerife<-distances_layer_from_to_tenerife[,c(1,3,2)]
#distances between the other islands
rest_distances<-distances %>% filter(!(layer_from == "TenerifeSouth" |layer_to == "TenerifeSouth"|
layer_from == "TenerifeTeno" |layer_to == "TenerifeTeno"))
#final distances
distances_normalized<-rbind(distances_layer_from_to_tenerife, rest_distances) %>%
rename("mean_distance" ="distance_in_meters" )
View(distances_normalized)
#add id of locations
distances_with_ids <- distances_normalized %>% left_join(layer_metadata, by= c("layer_from"="layer_name")) %>%
left_join(layer_metadata, by= c("layer_to"="layer_name")) %>% #add correct id to layer name
select(mean_distance, layer_id.x, layer_id.y) #discard actual names of layers
names(distances_with_ids)[2] <- "layer_from"
names(distances_with_ids)[3] <- "layer_to"
names(distances_with_ids)[1] <- "mean_distance"
View(distances_with_ids)
distances_with_ids <- distances_with_ids[c("layer_from", "layer_to", "mean_distance")]
## Jaccard on islands (locations) -----
#similarity check 2 furthest apart
modules_for_similarity_num <- modules %>% select(module, layer_id) %>%
unique() %>% group_by(module) %>% select(module) %>% unique()
modules_for_similarity <- modules %>%
filter(module %in% modules_for_similarity_num$module) #only save the modules that are found in 2 or more layers
#pivot modules function for islands as layers
pivot_by_module_islands <- function(data){ #creates a data frame with module on the side and layer_id on the top
s1 = melt(data, id = c("layer_id", "module"))
s2 = dcast(s1, layer_id ~ module, length)
s3 = t(s2)
s3 <- s3[-1,]
colnames(s3) <- c(1,2,3,4,5)
return(s3)
}
module_pivoted <- pivot_by_module_islands(modules_for_similarity)
View(module_pivoted)
i =1
module4[1]
module[1]
module_pivoted[1]
module_pivoted[4]
j=2
module_pivoted[j]
#edge list per module function for islands as layers
edge_list_per_module_islands <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:4)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):5)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
checkk<-edge_list_with_distances %>% group_by(layer_from,layer_to) %>%
unique()
View(checkk)
checkk<-edge_list_with_distances %>% group_by(layer_from,layer_to) %>%
distinct()
View(checkk)
checkk<-edge_list_with_distances %>% select(layer_from,layer_to) %>%
distinct()
View(checkk)
module_pivoted
module_pivoted[1,]
prueba<- module_pivoted[1,]
prueba[1]
view(prueba[1])
view(prueba[2])
edge_list_prueba<-rbind(tibble(layer_from=i, layer_to=j))
View(edge_list_prueba)
edge_list_prueba<-rbind(tibble(layer_from=i, layer_to=j, module=as.character(NA)))
View(edge_list_prueba)
edge_list_prueba<-rbind(tibble(layer_from=i, layer_to=j, module)
}
}
}
}
return(edge_list)
}
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
checkk<-edge_list_with_distances %>% select(layer_from,layer_to) %>%
distinct()
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances <- na.omit(edge_list_with_distances) #remove NA and delete layer name
#arrange data to include coordinates and modules sizes
size <- count(modules_dryad_multilayer$modules, module)  #create a data frame of all modules and how many nodes are in each (size of module)
module_data <- merge(modules_dryad_multilayer$modules , size, by=c("module","module")) #merge size of module with all the other info about the modules
colnames(module_data)[7] <- "size_of_module" #rename column
#write.csv(module_data, "./csvs_nuevo/module_data_justislands_as_layers.csv", row.names = FALSE)
#write.csv(size, "./csvs_nuevo/size_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read_csv('./csvs_nuevo/layers.csv') %>%
filter(!(layer_name =="WesternSahara1"| layer_name =="WesternSahara2" )) #create new data frame with just the layer data
lon_lat_data <- lon_lat_data %>% select(c("layer_id","lat","Lon")) %>% na.omit()  #only select layer id and coordinates
#layers as islands
old <- c(3,4,5,6,7,8,9,10,11,12,13,14)
new_values <- c(1,1,2,2,3,3,3,3,4,4,5,5)
lon_lat_data$layer_id[lon_lat_data$layer_id %in% old] <- new_values[match(lon_lat_data$layer_id, old)]
lon_lat_data <- lon_lat_data %>% unique() %>% #delete duplicates caused by islands having 2 sites
group_by(layer_id) %>% summarise(lat =mean(lat), long = mean(Lon))
#write.csv(lon_lat_data, "./csvs_nuevo/lon_lat_data_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read.csv("./csvs_nuevo/lon_lat_data_justislands_as_layers.csv")
module_data_with_loc <- merge(module_data, lon_lat_data, by= c("layer_id","layer_id")) #merge modules with module size with the coordinates
#how many layers are within a module
modules_with_lat_lon <- module_data_with_loc %>% select(layer_id, module, lat, long, size_of_module) %>% unique() #take only certain columns
modules_with_lat_lon$count <- c(1)
#write.csv(modules_with_lat_lon, "./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv", row.names = FALSE)
#modules_with_lat_lon <- read.csv("./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv")
#version with # of modules in layers
edge_list_by_islands_modules <- edge_list_with_distances
edge_list_by_islands_modules$count <- c(1)
edge_list_by_islands_modules <- edge_list_by_islands_modules %>% group_by(layer_from, layer_to) %>%
mutate(number_of_modules= sum(count)) %>% #count how many modules are shared by 2 islands
select(layer_from, layer_to, module, number_of_modules, mean_distance)
## Distance decay in modules -----
module_island_turnover <- NULL
for (i in (1:4)){
for (j in ((1+i):5)){
print(i)
modules_in_island_from <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_island_to <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all modules in one layer and all modules in another layer to check turnover
int_both <- intersect(modules_in_island_from, modules_in_island_to) #how many modules are found in both layers
uni_both <- union(modules_in_island_from, modules_in_island_to)
turnover <- length(int_both)/length(uni_both)
module_island_turnover <- rbind(module_island_turnover, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
islands_turnover_with_distnace_empirical <- edge_list_by_islands_modules %>%
merge(module_island_turnover, by= c("layer_from", "layer_to")) %>%
select(layer_from, layer_to, number_of_modules, mean_distance, turnover) %>% unique() #merge both versions
islands_turnover_with_distnace_empirical <- islands_turnover_with_distnace_empirical %>%
mutate(distance_in_km=mean_distance/1000) #turn to km
#write.csv(islands_turnover_with_distnace_empirical,  "./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv",  row.names = FALSE)
## Statistical analysis -----
emp <- read.csv("./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv", sep =",")
shapiro.test(islands_turnover_with_distnace_empirical$turnover)#normal
m_emp<-MRM(turnover ~ distance_in_km,data=emp,nperm=9999 )
View(edge_list_prueba)
View(edge_list_prueba)
edge_list_prueba<-rbind(tibble(layer_from=i, layer_to=j, module)
}
}
}
}
return(edge_list)
}
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
checkk<-edge_list_with_distances %>% select(layer_from,layer_to) %>%
distinct()
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
#edge_list_with_distances <- na.omit(edge_list_with_distances) #remove NA and delete layer name
#arrange data to include coordinates and modules sizes
size <- count(modules_dryad_multilayer$modules, module)  #create a data frame of all modules and how many nodes are in each (size of module)
module_data <- merge(modules_dryad_multilayer$modules , size, by=c("module","module")) #merge size of module with all the other info about the modules
colnames(module_data)[7] <- "size_of_module" #rename column
#write.csv(module_data, "./csvs_nuevo/module_data_justislands_as_layers.csv", row.names = FALSE)
#write.csv(size, "./csvs_nuevo/size_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read_csv('./csvs_nuevo/layers.csv') %>%
filter(!(layer_name =="WesternSahara1"| layer_name =="WesternSahara2" )) #create new data frame with just the layer data
lon_lat_data <- lon_lat_data %>% select(c("layer_id","lat","Lon")) %>% na.omit()  #only select layer id and coordinates
#layers as islands
old <- c(3,4,5,6,7,8,9,10,11,12,13,14)
new_values <- c(1,1,2,2,3,3,3,3,4,4,5,5)
lon_lat_data$layer_id[lon_lat_data$layer_id %in% old] <- new_values[match(lon_lat_data$layer_id, old)]
lon_lat_data <- lon_lat_data %>% unique() %>% #delete duplicates caused by islands having 2 sites
group_by(layer_id) %>% summarise(lat =mean(lat), long = mean(Lon))
#write.csv(lon_lat_data, "./csvs_nuevo/lon_lat_data_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read.csv("./csvs_nuevo/lon_lat_data_justislands_as_layers.csv")
module_data_with_loc <- merge(module_data, lon_lat_data, by= c("layer_id","layer_id")) #merge modules with module size with the coordinates
#how many layers are within a module
modules_with_lat_lon <- module_data_with_loc %>% select(layer_id, module, lat, long, size_of_module) %>% unique() #take only certain columns
modules_with_lat_lon$count <- c(1)
#write.csv(modules_with_lat_lon, "./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv", row.names = FALSE)
#modules_with_lat_lon <- read.csv("./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv")
#version with # of modules in layers
edge_list_by_islands_modules <- edge_list_with_distances
edge_list_by_islands_modules$count <- c(1)
edge_list_by_islands_modules <- edge_list_by_islands_modules %>% group_by(layer_from, layer_to) %>%
mutate(number_of_modules= sum(count)) %>% #count how many modules are shared by 2 islands
select(layer_from, layer_to, module, number_of_modules, mean_distance)
## Distance decay in modules -----
module_island_turnover <- NULL
for (i in (1:4)){
for (j in ((1+i):5)){
print(i)
modules_in_island_from <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_island_to <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all modules in one layer and all modules in another layer to check turnover
int_both <- intersect(modules_in_island_from, modules_in_island_to) #how many modules are found in both layers
uni_both <- union(modules_in_island_from, modules_in_island_to)
turnover <- length(int_both)/length(uni_both)
module_island_turnover <- rbind(module_island_turnover, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
islands_turnover_with_distnace_empirical <- edge_list_by_islands_modules %>%
merge(module_island_turnover, by= c("layer_from", "layer_to")) %>%
select(layer_from, layer_to, number_of_modules, mean_distance, turnover) %>% unique() #merge both versions
islands_turnover_with_distnace_empirical <- islands_turnover_with_distnace_empirical %>%
mutate(distance_in_km=mean_distance/1000) #turn to km
#write.csv(islands_turnover_with_distnace_empirical,  "./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv",  row.names = FALSE)
## Statistical analysis -----
emp <- read.csv("./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv", sep =",")
shapiro.test(islands_turnover_with_distnace_empirical$turnover)#normal
m_emp<-MRM(turnover ~ distance_in_km,data=emp,nperm=9999 )
edge_list_prueba<-rbind(tibble(layer_from=i, layer_to=j, module))
?tibble
module_pivoted <- pivot_by_module_islands(modules_for_similarity)
#edge list per module function for islands as layers
edge_list_per_module_islands <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:4)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):5)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
prueba<-module_pivoted[4,]
check<-edge_list_per_module_islands(prueba, modules_edge_list)
View(check)
prueba<-module_pivoted[4,]
prueba
View(modules_edge_list)
modules_edge_list <- NULL
check<-edge_list_per_module_islands(prueba, modules_edge_list)
View(check)
current_module <- rownames(module_pivoted)[4]
modules_edge_list <- check %>% mutate(module = replace_na(module, current_module)) #add module number
View(modules_edge_list)
prueba<-module_pivoted[4,]
check<-edge_list_per_module_islands(prueba, modules_edge_list)
#CUANDO LO HAGO UNO POR UNO VA BIEN PERO TODO JUNTO ME SALTEA MODULOS.. CASO DE FILA
modules_edge_list <- NULL
prueba<-module_pivoted[4,]
check<-edge_list_per_module_islands(prueba, modules_edge_list)
View(check)
i =4
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
View(modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
#CUANDO LO HAGO UNO POR UNO VA BIEN PERO TODO JUNTO ME SALTEA MODULOS.. CASO DE FILA
modules_edge_list <- NULL
try<-module_pivoted[1:2]
try<-module_pivoted[1:2,]
View(try)
module_pivoted[1:2,]
module_pivoted<-module_pivoted[1:2,]
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
#CUANDO LO HAGO UNO POR UNO VA BIEN PERO TODO JUNTO ME SALTEA MODULOS.. CASO DE FILA
modules_edge_list <- NULL
module_pivoted<-module_pivoted[1:2,]
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
View(modules_edge_list)
edge_list_with_distances <- right_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
edge_list_with_distances <- left_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
View(distances_with_ids)
View(edge_list_by_islands_modules)
View(edge_list_prueba)
View(edge_list_by_islands_modules)
View(edge_list_with_distances)
distances_with_ids_inverted<- tibble(layer_from=distances_with_ids$layer_to,
layer_to = distances_with_ids$layer_from,
distances_with_ids$mean_distance)
View(distances_with_ids_inverted)
distances_with_ids_inverted<- tibble(layer_from=distances_with_ids$layer_to,
layer_to = distances_with_ids$layer_from,
mean_distance = distances_with_ids$mean_distance)
distances_with_ids_final<-rbind(distances_with_ids,distances_with_ids_inverted) %>% unique()
View(distances_with_ids_final)
write.csv(distances_with_ids_final, "./csvs_nuevo/distances_with_ids_justislands_as_layers.csv", row.names = FALSE)
## Jaccard on islands (locations) -----
#similarity check 2 furthest apart
modules_for_similarity_num <- modules %>% select(module, layer_id) %>%
unique() %>% group_by(module) %>% select(module) %>% unique()
modules_for_similarity <- modules %>%
filter(module %in% modules_for_similarity_num$module) #only save the modules that are found in 2 or more layers
#pivot modules function for islands as layers
pivot_by_module_islands <- function(data){ #creates a data frame with module on the side and layer_id on the top
s1 = melt(data, id = c("layer_id", "module"))
s2 = dcast(s1, layer_id ~ module, length)
s3 = t(s2)
s3 <- s3[-1,]
colnames(s3) <- c(1,2,3,4,5)
return(s3)
}
module_pivoted <- pivot_by_module_islands(modules_for_similarity)
#edge list per module function for islands as layers
edge_list_per_module_islands <- function(data,edge_list){
#gets one row from a data frame and creates an edge list from it
for (i in (1:4)){
if (data[i]==0) next #only take layers where the module is present
else {
for (j in ((i+1):5)){
if (data[j]==0) next #only take layers where the module is present
else {
edge_list <- rbind(edge_list, tibble(layer_from=i, layer_to=j, module=as.character(NA))) #create edge list of all the layer found in a module
}
}
}
}
return(edge_list)
}
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
distances_with_ids<-read.csv("./csvs_nuevo/distances_with_ids_justislands_as_layers.csv")
edge_list_with_distances <- left_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
View(edge_list_with_distances)
modules_edge_list <- NULL
for (i in (1:nrow(module_pivoted))){ #run the function for each row in the data frame
modules_edge_list <- edge_list_per_module_islands(module_pivoted[i,], modules_edge_list)
current_module <- rownames(module_pivoted)[i]
modules_edge_list <- modules_edge_list %>% mutate(module = replace_na(module, current_module)) #add module number
}
edge_list_with_distances <- left_join(modules_edge_list, distances_with_ids, by= c("layer_from", "layer_to")) #combine the edge list with the distances between each two layers
edge_list_with_distances <- na.omit(edge_list_with_distances) #remove NA and delete layer name
View(edge_list_with_distances)
#arrange data to include coordinates and modules sizes
size <- count(modules_dryad_multilayer$modules, module)  #create a data frame of all modules and how many nodes are in each (size of module)
module_data <- merge(modules_dryad_multilayer$modules , size, by=c("module","module")) #merge size of module with all the other info about the modules
colnames(module_data)[7] <- "size_of_module" #rename column
write.csv(module_data, "./csvs_nuevo/module_data_justislands_as_layers.csv", row.names = FALSE)
write.csv(size, "./csvs_nuevo/size_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read_csv('./csvs_nuevo/layers.csv') %>%
filter(!(layer_name =="WesternSahara1"| layer_name =="WesternSahara2" )) #create new data frame with just the layer data
lon_lat_data <- lon_lat_data %>% select(c("layer_id","lat","Lon")) %>% na.omit()  #only select layer id and coordinates
#layers as islands
old <- c(3,4,5,6,7,8,9,10,11,12,13,14)
new_values <- c(1,1,2,2,3,3,3,3,4,4,5,5)
lon_lat_data$layer_id[lon_lat_data$layer_id %in% old] <- new_values[match(lon_lat_data$layer_id, old)]
lon_lat_data <- lon_lat_data %>% unique() %>% #delete duplicates caused by islands having 2 sites
group_by(layer_id) %>% summarise(lat =mean(lat), long = mean(Lon))
write.csv(lon_lat_data, "./csvs_nuevo/lon_lat_data_justislands_as_layers.csv", row.names = FALSE)
#write.csv(lon_lat_data, "./csvs_nuevo/lon_lat_data_justislands_as_layers.csv", row.names = FALSE)
lon_lat_data <- read.csv("./csvs_nuevo/lon_lat_data_justislands_as_layers.csv")
module_data_with_loc <- merge(module_data, lon_lat_data, by= c("layer_id","layer_id")) #merge modules with module size with the coordinates
#how many layers are within a module
modules_with_lat_lon <- module_data_with_loc %>% select(layer_id, module, lat, long, size_of_module) %>% unique() #take only certain columns
modules_with_lat_lon$count <- c(1)
write.csv(modules_with_lat_lon, "./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv", row.names = FALSE)
#write.csv(modules_with_lat_lon, "./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv", row.names = FALSE)
modules_with_lat_lon <- read.csv("./csvs_nuevo/modules_with_lat_lon_justislands_as_layers.csv")
#version with # of modules in layers
edge_list_by_islands_modules <- edge_list_with_distances
edge_list_by_islands_modules$count <- c(1)
edge_list_by_islands_modules <- edge_list_by_islands_modules %>% group_by(layer_from, layer_to) %>%
mutate(number_of_modules= sum(count)) %>% #count how many modules are shared by 2 islands
select(layer_from, layer_to, module, number_of_modules, mean_distance)
## Distance decay in modules -----
module_island_turnover <- NULL
for (i in (1:4)){
for (j in ((1+i):5)){
print(i)
modules_in_island_from <- filter(modules_with_lat_lon, layer_id == i) %>% select(module) %>% unique() %>% unlist()
modules_in_island_to <- filter(modules_with_lat_lon, layer_id == j) %>% select(module) %>% unique() %>% unlist()
#take all modules in one layer and all modules in another layer to check turnover
int_both <- intersect(modules_in_island_from, modules_in_island_to) #how many modules are found in both layers
uni_both <- union(modules_in_island_from, modules_in_island_to)
turnover <- length(int_both)/length(uni_both)
module_island_turnover <- rbind(module_island_turnover, tibble(layer_from= i, layer_to= j, turnover= turnover))
}
}
islands_turnover_with_distnace_empirical <- edge_list_by_islands_modules %>%
merge(module_island_turnover, by= c("layer_from", "layer_to")) %>%
select(layer_from, layer_to, number_of_modules, mean_distance, turnover) %>% unique() #merge both versions
islands_turnover_with_distnace_empirical <- islands_turnover_with_distnace_empirical %>%
mutate(distance_in_km=mean_distance/1000) #turn to km
View(islands_turnover_with_distnace_empirical)
write.csv(islands_turnover_with_distnace_empirical,  "./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv",  row.names = FALSE)
## Statistical analysis -----
emp <- read.csv("./csvs_nuevo/justislands_turnover_with_distnace_empirical.csv", sep =",")
shapiro.test(islands_turnover_with_distnace_empirical$turnover)#normal
m_emp<-MRM(turnover ~ distance_in_km,data=emp,nperm=9999 )
summary(m_emp)
m_emp
#
islands_turnover_with_distnace_empirical %>%
ggplot(aes(x=distance_in_km, y=turnover))+
geom_point(color = "indianred2")+ scale_x_continuous()+theme_classic()+
stat_smooth(method= "lm", se = F, color = "indianred2")+
theme(axis.title=element_text(size=22))+theme(axis.text.x=element_text(size=15))+
theme(axis.text.y=element_text(size=15))+
labs(x="Distance in Km", y="Jaccard Similarity")+
theme(panel.grid = element_blank(),
panel.border = element_rect(color = "black",fill = NA,size = 1),
panel.spacing = unit(0.5, "cm", data = NULL),
axis.text = element_text(size=14, color='black'),
axis.title = element_text(size=14, color='black'),
axis.line = element_blank())
